//! CSRF (cross-site request forgery) protection.
//!
//! CSRF is a common phishing attack, fooling your
//! users into making changes to their data managed by your application.
//! CSRF protection ensures that forms submitted via POST
//! to the web app are coming from the form generated by the same website.
//!
//! ### Usage
//! CSRF protection is enabled by default. To make it work, include a Rwf-generated token
//! in all forms submitted via POST:
//!
//! ```html
//! <form method="post">
//!     <%= csrf_token() %>
//! </form>
//! ```
//!
//! If used via AJAX, include the CSRF token in the `X-CSRF-Token` header.
//! You can obtain the token by calling the `csrf_token_raw` template function:
//!
//! ```html
//! <script>
//!     window.csrf_token = "<%= csrf_token_raw() %>";
//! </script>
//! ```
//!
//! ### Configuration
//! Toggle `csrf_protection` in the configuration to enable/disable CSRF protection application-wide, e.g.:
//!
//! ```toml
//! [general]
//! csrf_protection = false
//! ```

use super::prelude::*;
use crate::{crypto::csrf_token_validate, http::Method};
use utoipa::openapi::OpenApi;

/// CSRF HTTP header name.
pub static CSRF_HEADER: &str = "X-CSRF-Token";
/// CSRF HTTP form input name.
pub static CSRF_INPUT: &str = "rwf_csrf_token";

/// CSRF protection middleware.
pub struct Csrf;

impl Csrf {
    /// Create CSRF protection middleware.
    pub fn new() -> Self {
        Self {}
    }
}

#[async_trait]
impl Middleware for Csrf {
    async fn handle_request(&self, request: Request) -> Result<Outcome, Error> {
        if request.skip_csrf() {
            return Ok(Outcome::Forward(request));
        }

        if ![Method::Put, Method::Post, Method::Patch].contains(request.method()) {
            return Ok(Outcome::Forward(request));
        }

        let header = request.header(CSRF_HEADER);
        let session_id = request.session_id().to_string();

        if let Some(header) = header {
            if csrf_token_validate(header, &session_id) {
                return Ok(Outcome::Forward(request));
            }
        }

        if let Ok(form_data) = request.form_data() {
            if let Some(token) = form_data.get::<String>(CSRF_INPUT) {
                if csrf_token_validate(&token, &session_id) {
                    return Ok(Outcome::Forward(request));
                }
            }
        }

        Ok(Outcome::Stop(request, Response::csrf_error()))
    }
}

impl utoipa::Modify for Csrf {
    fn modify(&self, openapi: &mut OpenApi) {
        let csrf_token = utoipa::openapi::schema::Schema::Object(
            utoipa::openapi::Object::builder()
                .description(Some("A CSRF Token".to_string()))
                .format(Some(utoipa::openapi::schema::SchemaFormat::KnownFormat(
                    utoipa::openapi::schema::KnownFormat::Password,
                )))
                .schema_type(utoipa::openapi::Type::String)
                .examples(vec![serde_json::json!(crate::crypto::csrf_token(
                    crate::controller::SessionId::from(1234)
                        .to_string()
                        .as_str()
                )
                .unwrap())])
                .build(),
        );
        if let Some(ref mut componenets) = openapi.components {
            componenets.schemas.insert(
                "csrf_token".to_string(),
                utoipa::openapi::RefOr::T(csrf_token),
            );
        }
        let csrf_token =
            utoipa::openapi::RefOr::Ref(utoipa::openapi::Ref::from_schema_name("csrf_token"));
        let param_header = utoipa::openapi::path::ParameterBuilder::new()
            .name(CSRF_HEADER)
            .parameter_in(utoipa::openapi::path::ParameterIn::Header)
            .description(Some("CSRF Token located in the Header."))
            .style(Some(utoipa::openapi::path::ParameterStyle::Simple))
            .schema(Some(csrf_token.clone()))
            .build();
        let param_query = utoipa::openapi::path::ParameterBuilder::new()
            .name(CSRF_INPUT)
            .parameter_in(utoipa::openapi::path::ParameterIn::Query)
            .style(Some(utoipa::openapi::path::ParameterStyle::Form))
            .description(Some("CSRF Token located in the Form Body"))
            .style(Some(utoipa::openapi::path::ParameterStyle::Form))
            .schema(Some(csrf_token.clone()))
            .build();
        for path in openapi.paths.paths.values_mut() {
            for ref mut op in [path.post.as_mut(), path.put.as_mut(), path.patch.as_mut()]
                .iter_mut()
                .flatten()
            {
                if let Some(ref mut params) = op.parameters {
                    params.push(param_query.clone());
                    params.push(param_header.clone())
                }
            }
        }
    }
}
