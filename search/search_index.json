{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>Rust Web Framework (Rwf for short) is a framework for building web applications using the Rust programming language. It aims to be comprehensive by providing all necessary features for building modern, fast, and secure web apps.</p> <p>Rwf has very few dependencies and is easy use with new or existing Rust applications.</p>"},{"location":"#install-rust","title":"Install Rust","text":"<p>If you haven't already, install the Rust compiler and tools from rust-lang.org. Rwf doesn't use any nightly or experimental features, so the stable version of the compiler will work.</p>"},{"location":"#create-a-project","title":"Create a project","text":"<p>Rwf can be used with any Rust binary or library project. If you don't have one already, you can create it with Cargo<sup>1</sup>:</p> <pre><code>cargo init --bin rwf-web-app &amp;&amp;\ncd rwf-web-app\n</code></pre>"},{"location":"#add-rwf","title":"Add Rwf","text":"<p>Rwf primarily consists of the <code>rwf</code> crate<sup>2</sup>. You can add it to your project with Cargo:</p> <pre><code>cargo add rwf\n</code></pre>"},{"location":"#build-an-application","title":"Build an application","text":"<p>With the <code>rwf</code> crate added, you're ready to build your first web application in Rust. Rwf is MVC (model-view-controller), so to get started let's create a simple controller:</p> <pre><code>use rwf::prelude::*;\n\n#[controller]\nasync fn index() -&gt; Response {\n    Response::new().html(\"&lt;h1&gt;My first Rwf app!&lt;/h1&gt;\")\n}\n</code></pre> <p><code>rwf::prelude::*</code> includes most types, traits and functions you'll need to build applications. Adding this declaration to your source code will make things easier, but it's not required.</p> <p><code>#[controller]</code> macro creates a controller from any async function that returns a <code>Response</code>.</p>"},{"location":"#launch-the-server","title":"Launch the server","text":"<p>With a controller ready to go, let's create a route and launch the Rwf HTTP server:</p> <pre><code>use rwf::http::{self, Server};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), http::Error&gt; {\n    // Configure the logger.\n    Logger::init();\n\n    // Define routes.\n    let routes = vec![\n        route!(\"/\" =&gt; index),\n    ];\n\n    // Launch the HTTP server.\n    Server::new(routes)\n        .launch()\n        .await\n}\n</code></pre> <p>Your application is ready. You can launch it with Cargo:</p> <pre><code>cargo run\n</code></pre> <p>Once the server is running, your web application will be available at http://localhost:8000. The full code for this is available on GitHub.</p>"},{"location":"#learn-more","title":"Learn more","text":"<ul> <li>Controllers</li> <li>Models</li> <li>Views</li> </ul> <ol> <li> <p>Cargo is the package manager for the Rust programming language. It can install any open source library available on crates.io.\u00a0\u21a9</p> </li> <li> <p>A crate is a library that can be used in Rust applications. It's similar to packages in JavaScript or Python.\u00a0\u21a9</p> </li> </ol>"},{"location":"configuration/","title":"Configuration","text":"<p>Rwf supports file-based and environment-based configuration. The list of configurable options are ever growing, and currently supported features are listed below.</p>"},{"location":"configuration/#enabling-configuration","title":"Enabling configuration","text":"<p>To configure Rwf, place a file called <code>rwf.toml</code> into the working directory of your app. During development, this should be the root directory of your Cargo project. At startup, Rwf will automatically load configuration settings from that file, as they are needed by the application.</p>"},{"location":"configuration/#available-settings","title":"Available settings","text":"<p>The configuration file is using the TOML language. If you're not familiar with TOML, it's pretty simple and expressive language commonly used in the world of Rust programming.</p> <p>Rwf configuration file is split into multiple sections. The <code>[general]</code> section controls various options such as logging settings, and which secret key to use for encryption. The <code>[database]</code> section configures database connection settings, like the database URL, connection pool size, and others.</p>"},{"location":"configuration/#general","title":"<code>[general]</code>","text":"Setting Description Default <code>host</code> Address of the network interface to launch Rwf on, e.g. <code>0.0.0.0</code>. <code>0.0.0.0</code> <code>port</code> Network port Rwf server will listen on for HTTP connections. <code>8000</code> <code>log_queries</code> Toggles logging of all SQL queries executed by the ORM. <code>false</code> <code>secret_key</code> Secret key, encoded using base64, used for encryption. Randomly generated <code>cache_templates</code> Toggle caching of dynamic templates. <code>false</code> in debug, <code>true</code> in release <code>csrf_protection</code> Validate the CSRF token is present on requests that mutate your application (POST, PUT, PATCH). <code>true</code> <code>max_request_size</code> Maximum <code>Content-Length</code> the server will process. Any requests larger than this will be rejected. 5 MB"},{"location":"configuration/#secret-key","title":"Secret key","text":"<p>The secret key is a base64-encoded string of randomly generated data. A valid secret key contains 256 bits of entropy and must be generated using a secure random number generator.</p> <p>If you have Python installed on your system, you can generate a secret key for Rwf in just a few lines of code:</p> PythonOutput <pre><code>import base64\nimport secrets\n\nsecret = base64.b64encode(secrets.token_bytes(int(256/8)))\nprint(secret)\n</code></pre> <pre><code>BJ3Og8l/Q8f+fLvQpb9CP7uUu/VG1/+CN2a1f/QyHWY=\n</code></pre> <p>Warning</p> <p>Do not use this example key in production. Always generate a new one and keep it secret.</p>"},{"location":"configuration/#database","title":"<code>[database]</code>","text":"Setting Description Default <code>name</code> Name of the database to connect to. Same as the <code>$USER</code> shell variable. If not set, default is <code>postgres</code>. <code>user</code> Name of the user to connect with to the database. <code>$USER</code>, or <code>postgres</code> if not set. <code>url</code> Fully-qualified database connection string. <code>postgresql://{user}/localhost:5432/{name}</code>, where <code>{user}</code> and <code>{name}</code> are <code>name</code> and <code>user</code> configuration values. <code>checkout_timeout</code> Amount of time to wait for a connection from the pool before returning an error (in milliseconds). <code>5000</code> (5 seconds) <code>idle_timeout</code> Amount of time to wait before closing an idle database connection. <code>3600000</code> (1 hour)"},{"location":"configuration/#url","title":"<code>url</code>","text":"<p>The database URL was originally created by The Twelve Factor App and uses the URL format for specifying database connections. It follows a standard format, as follows:</p> <pre><code>driver://user:password@host:port/database_name\n</code></pre> <p>For connecting to PostgreSQL, the <code>driver</code> is <code>postgresql</code> (or <code>postgres</code> is also acceptable).</p>"},{"location":"logging/","title":"Logging","text":"<p>Rwf uses the <code>tracing</code> crate for logging. The crate employs the standard <code>INFO</code>, <code>WARN</code>, <code>ERROR</code>, and <code>DEBUG</code> levels to output information of different importance. If you have a logging preference, e.g. you want to use JSON-structured logs without colors, you can use a logging subscriber of your choice. Alternatively, you can use the logger that comes with Rwf, like so:</p> <pre><code>use rwf::prelude::*;\n\n#[tokio::main]\nasync fn main() {\n    // Make sure to call this only once in your application.\n    Logger::init();\n\n    /* ... */\n}\n</code></pre>"},{"location":"logging/#log-queries","title":"Log queries","text":"<p>By default, queries executed against the database are not logged. If you want to see what's being executed (and how long queries are taking to return results), toggle the <code>log_queries</code> setting in the configuration.</p>"},{"location":"logging/#log-requests","title":"Log requests","text":"<p>All HTTP requests to Rwf are logged at the <code>INFO</code> level. This is useful in production to detect application activity and debug any issues (e.g. bad load balancer configuration).</p>"},{"location":"logging/#default-log-level","title":"Default log level","text":"<p>By default, Rwf applications are launched with the <code>INFO</code> log level. Since Rwf <code>Logger</code> is using <code>tracing-subscriber</code>, you can change that by setting the <code>RUST_LOG</code> environment variable, for example:</p> <pre><code>export RUST_LOG=debug\n</code></pre>"},{"location":"migrating-from-python/","title":"Migrating from Python","text":"<p>Rwf is written in Rust, so if you have an existing application you want to migrate to Rust, you have options. Rwf comes with its own WSGI server, so you can run your existing Django or Flask apps without modifications, side by side with Rwf controllers.</p>"},{"location":"migrating-from-python/#using-wsgi","title":"Using WSGI","text":"<p>Note</p> <p>Rwf WSGI server is still experimental and is not as advanced as the popular uWSGI project.</p> <p>Adding a WSGI application to your Rwf server is pretty straight forward. First, make sure that the Python project is in your <code>PYTHONPATH</code>, for example:</p> <pre><code>export PYTHONPATH=/path/to/python/project\n</code></pre> <p>Rwf will load your Python app directly into its own memory (using pyo3), so it needs to be able to find it when importing your app modules.</p>"},{"location":"migrating-from-python/#django","title":"Django","text":"<p>Django applications come with a WSGI interface, which Rwf can use directly. Usually, the interface is located in its own file, e.g. <code>project/wsgi.py</code>. The <code>WsgiController</code> accepts the Python module as an argument on initialization, in this case, <code>project.wsgi</code>.</p> <p>Once initialized, the controller can be added into the server, and mounted on the <code>/*</code> (root, wildcard) path. This ensures that all requests are handled by Django:</p> <pre><code>use rwf::prelude::*;\nuse rwf::http::Server;\nuse rwf::controller::WsgiController;\n\n#[tokio::main]\nasync fn main() {\n    Server::new(vec![\n        WsgiController::new(\"project.wsgi\")\n            .wildcard(\"/\"),\n    ])\n    .launch()\n    .await\n    .unwrap();\n}\n</code></pre>"},{"location":"migrating-from-python/#python-dependencies","title":"Python dependencies","text":"<p>Your application most likely has other dependencies, e.g. <code>django</code>, or <code>Flask</code> packages, and many more. To make sure they work when loaded into Rwf, either create and activate a virtual environment before launching the server, or install those packages globally (e.g., when deploying with Docker).</p>"},{"location":"migrating-from-python/#moving-traffic-to-rust","title":"Moving traffic to Rust","text":"<p>As you rewrite your endpoints to use Rwf and Rust, you can move traffic one route at time without disrupting your users. For example, if you are ready to move the route <code>/users</code> to Rust, add the controller for it into the server:</p> <pre><code>/// Your new \"/users\" controller\n/// written in Rust.\nuse crate::controllers::Users;\n\n#[tokio::main]\nasync fn main() {\n    Server::new(vec![\n        WsgiController::new(\"project.wsgi\")\n            .wildcard(\"/\"),\n        route!(\"/users\" =&gt; Users),\n    ])\n    .launch()\n    .await\n    .unwrap()\n}\n</code></pre> <p>Rwf routing algorithm will match requests to <code>/users</code> to the <code>Users</code> controller instead of sending it to WSGI, because the <code>Users</code> controller path is more specific and has higher priority than wildcard routes.</p>"},{"location":"migrating-from-python/#learn-more","title":"Learn more","text":"<ul> <li>examples/django</li> </ul>"},{"location":"migrating-from-rails/","title":"Migrating from Rails","text":"<p>Rwf comes with its own Rack server which you can run side by side with your controllers. This allows you to run your Rails app inside Rwf, while moving traffic from Rails controllers to Rwf controllers without downtime.</p>"},{"location":"migrating-from-rails/#running-rails","title":"Running Rails","text":"<p>Note</p> <p>Our Rack server is currently highly experimental. Ruby doesn't have ergonomic bindings to Rust (unlike Python), so a lot of this had to be written specifically for this project.</p>"},{"location":"migrating-from-rails/#ruby","title":"Ruby","text":"<p>Depending on your operating system, Ruby installation may differ.</p>"},{"location":"migrating-from-rails/#linux","title":"Linux","text":"<p>On Linux, you can install Ruby using your package manager. Since Rails uses Bundler to manage dependencies, make sure you set the <code>GEM_HOME</code> environment variable to a folder writable by your UNIX user, e.g. <code>~/.gems</code>:</p> <pre><code>mkdir -p ~/.gems\nexport GEM_HOME=~/.gems\n</code></pre> <p>Since we'll be compiling our Ruby bindings from source, make sure to install the Ruby headers as well. On most systems, that'll come from the <code>ruby-dev</code> package.</p>"},{"location":"migrating-from-rails/#mac-os","title":"Mac OS","text":"<p>Mac OS comes with its own Ruby version, however it's very much out of date and won't work with modern Rails apps. You'll need to install Ruby from homebrew:</p> <pre><code>brew install ruby\n</code></pre> <p>When building a Rwf app with Ruby bindings, you'll need to make sure the linker can find the right Ruby library. Since you'll have two versions of Ruby installed at this point, the linker will get confused and use the system one, which won't work. To get around this, create a <code>.cargo/config</code> file in your project, and add the right library path to the linker arguments:</p> <pre><code>[build]\nrustflags = [\"-C\", \"link-args=-L/opt/homebrew/Cellar/ruby/3.3.4/lib\"]\n</code></pre> <p>The path here will depend on the version of Ruby you have installed with homebrew.</p>"},{"location":"migrating-from-rails/#running-the-app","title":"Running the app","text":"<p>Running a Rails app with Rwf requires only adding the built-in Rack controller to your server:</p> <pre><code>use rwf::prelude::*;\nuse rwf::http::{Server, self};\nuse rwf::controllers::RackController;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), http::Error&gt; {\n    Server::new(vec![\n        RackController::new(\"path/to/your/rails/app\")\n            .wildcard(\"/\")\n    ])\n    .launch()\n    .await\n}\n</code></pre> <p>The <code>RackController</code> takes the path (relative or absolute) to your Rails application as an argument.</p>"},{"location":"migrating-from-rails/#learn-more","title":"Learn more","text":"<ul> <li>examples/rails</li> </ul>"},{"location":"background-jobs/","title":"Jobs overview","text":"<p>Background jobs, also known as asynchronous jobs, are code that can run independently of the main HTTP request/response life cycle. Executing code in background jobs allows you to perform useful work without making the client wait for the job to finish. Examples of background jobs are sending emails or talking to third-party APIs.</p> <p>Rwf has its own background job queue and workers that can perform those jobs.</p>"},{"location":"background-jobs/#defining-jobs","title":"Defining jobs","text":"<p>A background job is any Rust struct that implements the <code>Job</code> trait. The only trait method the job needs to implement is the <code>async fn execute</code> method which accepts job arguments encoded with JSON.</p> <p>For example, if we wanted to send a welcome email to all users that sign up for your web app, we can do so as a background job:</p> <pre><code>use rwf::prelude::*;\nuse rwf::job::{Error as JobError};\nuse serde::{Serialize, Deserialize};\n\n#[derive(Default, Debug, Serialize, Deserialize)]\nstruct WelcomeEmail {\n    email: String,\n    user_name: String,\n}\n\n#[async_trait]\nimpl Job for WelcomeEmail {\n    /// Code in this function will be executed in the background.\n    async fn execute(&amp;self, args: serde_json::Value) -&gt; Result&lt;(), JobError&gt; {\n        let args: WelcomeEmail = serde_json::from_value(args)?;\n\n        // Send the email to the user\n        // with the given email address.\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"background-jobs/#spawning-workers","title":"Spawning workers","text":"<p>Once we have background jobs, we need to create background workers that will run in separate threads (Tokio tasks, in reality), and execute those jobs as they are sent to the queue. Spawning workers can be done from anywhere in the code, but typically done so from the <code>main</code> function:</p> <pre><code>use rwf::job::Worker;\nuse tokio::time::{sleep, Duration};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Error&gt; {\n    // Create a new worker with 4 threads.\n    let worker = Worker::new(vec![\n        WelcomeEmail::default().job()\n    ])\n\n    worker.start().await?;\n\n    //  Put the main task to sleep indefinitely.\n    sleep(Duration::MAX).await;\n}\n</code></pre>"},{"location":"background-jobs/#sharing-processes","title":"Sharing processes","text":"<p>Workers can be spawned inside the app without having to create a separate binary application. Since most jobs will be running async code, Tokio will effectively load balance foreground (HTTP requests/responses) and background workloads.</p> <p>To spawn a worker inside the web app, use the code above without the <code>sleep</code>. The <code>Worker::start</code> method returns almost immediately, since it only spawns a worker on a separate Tokio task.</p>"},{"location":"background-jobs/#scheduling-jobs","title":"Scheduling jobs","text":"<p>With the background jobs defined and the workers running, we can start scheduling jobs to run in the background. A job can be scheduled to run from anywhere in the code by calling the <code>queue_async</code> method:</p> <pre><code>let email = WelcomeEmail {\n    email: \"new-user@example.com\".to_string(),\n    user_name: \"Alice\".to_string(),\n};\n\n// Schedule the job to run in the background\n// as soon as possible.\nqueue_async(&amp;email).await?;\n</code></pre> <p>The <code>queue_async</code> method creates a record of the job in the queue and returns immediately without doing the actual work. This makes this method very quick so you can schedule multiple jobs inside a controller without it having noticeable effect on endpoint latency.</p>"},{"location":"background-jobs/cron/","title":"Cron jobs","text":"<p>Cron jobs, or scheduled jobs, are background jobs that are performed automatically based on a schedule. For example, if you want to send a newsletter to your users every week, you can create a background job and schedule it to run weekly using the built-in cron.</p>"},{"location":"background-jobs/cron/#defining-scheduled-jobs","title":"Defining scheduled jobs","text":"<p>A scheduled job is a regular background job, for example:</p> <pre><code>use rwf::prelude::*;\nuse rwf::job::{Error as JobError};\n\n#[derive(Default, Debug, Serialize, Deserialize)]\nstruct WeeklyNewsletter;\n\n#[async_trait]\nimpl Job for WeeklyNewsletter {\n    /// Code in this function will be executed in\n    /// the background.\n    async fn execute(&amp;self, _args: serde_json::Value) -&gt; Result&lt;(), JobError&gt; {\n        // Send the newsletter to all users.\n        Ok(())\n    }\n}\n</code></pre> <p>To run a job on a schedule, you need to add it in two places:</p> <ul> <li>The list of jobs the worker can run</li> <li>The crontab (or the clock, as we call it)</li> </ul> <pre><code>// Crontab\nlet schedule = vec![\n    WeeklyNewsletter::default()\n        .schedule(\n            serde_json::Value::Null,\n            \"0 0 * * 0\",\n        ), // Every Sunday at midnight\n];\n\n// Background jobs\nlet jobs = vec![\n    WeeklyNewsletter::default().job()\n];\n\nlet worker = Worker::new(jobs)\n    .clock(schedule);\n\nworker.start().await?;\n</code></pre>"},{"location":"background-jobs/queue-guarantees/","title":"Job queue guarantees","text":"<p>The background queue is stored in the database, so jobs will not get lost. Workers will attempt to run a job at least once. Even if workers crash, when they are restarted, any running jobs will be rescheduled.</p> <p>Because of this guarantee, jobs should strive to be idempotent: the same job can be executed multiple times.</p>"},{"location":"background-jobs/queue-guarantees/#performance","title":"Performance","text":"<p>The job queue is using PostgreSQL's <code>FOR UPDATE SKIP LOCKED</code> mechanism, which has been shown to support high concurrency job queues.</p>"},{"location":"background-jobs/queue-guarantees/#polling","title":"Polling","text":"<p>Workers poll the queue every second. If there are no jobs, the worker goes to sleep and polls again in one second. If a job is available, it will be executed immediately. Once the job completes, the worker will attempt to fetch the next job immediately, restarting this cycle.</p>"},{"location":"background-jobs/queue-guarantees/#concurrency","title":"Concurrency","text":"<p>By default, a worker executes one job at a time. This allows to control for background concurrency easily, without complex throttling mechanisms. If you want to execute many jobs concurrently, you can spawn as many workers as you wish. Each worker will poll the queue for jobs once a second.</p> <p>To spawn more workers, call <code>Worker::spawn</code> as many times as you wish to have workers, for example:</p> <pre><code>let worker = Worker::new(vec![])\n  .start()\n  .await?\n  .spawn()\n  .spawn()\n  .spawn();\n</code></pre> <p>The above code will spawn 4 workers in total.</p>"},{"location":"controllers/","title":"Controller basics","text":"<p>Rwf comes with multiple pre-built controllers that can be used out of the box, for example, to handle WebSocket connections, REST-style interactions, or serving static files. For everything else, the <code>Controller</code> trait can be implemented to handle any kind of HTTP requests.</p>"},{"location":"controllers/#whats-a-controller","title":"What's a controller?","text":"<p>The controller is the C in MVC: it handles user interactions with the web app and performs actions on their behalf. A controller takes care of user inputs, like forms, and all other HTTP requests to the app.</p>"},{"location":"controllers/#writing-a-controller","title":"Writing a controller","text":"<p>Simple controllers can be written using the <code>#[controller]</code> macro, which accepts any async function that returns a <code>Response</code>, for example:</p> <pre><code>#[controller]\nasync fn my_controller() -&gt; Response {\n    Response::new().html(\"&lt;h1&gt;My controller is working!&lt;/h1&gt;\")\n}\n</code></pre> <p>Internally, the macro is generating a Rust struct that implements the <code>Controller</code> trait. While simple controllers can use the macro, more complex controllers can be built by defining a struct and implementing the trait manually.</p> <p>As an example, let's write a controller that returns the current time in UTC.</p>"},{"location":"controllers/#import-types","title":"Import types","text":"<pre><code>use rwf::prelude::*;\n</code></pre> <p>The prelude module contains most of the types and traits necessary to work with Rwf. Including it will save you time and effort when writing code.</p>"},{"location":"controllers/#define-the-struct","title":"Define the struct","text":"<pre><code>#[derive(Default)]\nstruct CurrentTime;\n</code></pre> <p>This struct has no fields, but you can add any internal state you want to keep track of in there. The <code>Default</code> trait is derived automatically to provide a convenient way to instantiate it.</p>"},{"location":"controllers/#implement-the-controller-trait","title":"Implement the <code>Controller</code> trait","text":"<pre><code>#[async_trait]\nimpl Controller for CurrentTime {\n    /// This function handles incoming HTTP requests.\n    async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        let time = OffsetDateTime::now_utc();\n\n        // This creates an HTTP \"200 OK\" response,\n        // with \"Content-Type: text/plain\" header.\n        let response = Response::new()\n            .text(format!(\"The current time is: {:?}\", time));\n\n        Ok(response)\n    }\n}\n</code></pre> <p>The <code>Controller</code> trait is asynchronous. Support for async traits in Rust is still incomplete, so we use the <code>async_trait</code> library to make it easy to use. The trait itself has a few methods, most of which have reasonable defaults. The only method that needs to be written by hand is <code>async fn handle</code>.</p>"},{"location":"controllers/#async-fn-handle","title":"<code>async fn handle</code>","text":"<p>This method accepts a <code>Request</code> and must return a <code>Response</code>. The response can be any valid HTTP response, including <code>404</code> or even <code>500</code>.</p>"},{"location":"controllers/#errors","title":"Errors","text":"<p>If an error occurs inside the <code>async fn handle</code> function, Rwf will return HTTP <code>500</code> automatically and display the error to the client.</p>"},{"location":"controllers/#connecting-controllers","title":"Connecting controllers","text":"<p>Once you implement a controller, adding it to the app requires mapping it to a route. A route is a unique URL, starting at the root of the app. For example, <code>/signup</code> is a route that could map to the <code>Signup</code> controller, and allow your users to create accounts.</p> <p>Adding controllers to the app happens at server startup. A server can be launched from an async task anywhere in the code, but typically is done so from the <code>main</code> function:</p> <pre><code>use rwf::prelude::*;\nuse rwf::http::{self, Server};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), http::Error&gt; {\n    Server::new(vec![\n        // Map the `/time` route to the `CurrentTime` controller.\n        route!(\"/time\" =&gt; CurrentTime),\n    ])\n    .launch()\n    .await\n}\n</code></pre> <p>Note</p> <p>The <code>route!</code> macro is a shorthand for calling <code>CurrentTime::default().route(\"/time\")</code>. We use it because it looks cool, but it's not required. You can instantiate your controller struct in any way you need, and call the <code>Controller::route</code> method when adding it to the server. Alternatively, you can implement the <code>Default</code> trait like we did in this example and use the macro.</p>"},{"location":"controllers/#test-with-curl","title":"Test with cURL","text":"<p>Once the server is up and running, you can test your endpoints with cURL (or with a regular browser, like Firefox):</p> cURLOutput <pre><code>curl localhost:8000/time -w '\\n'\n</code></pre> <pre><code>The current time is: 2024-10-17 0:23:34.6191103 +00:00:00\n</code></pre>"},{"location":"controllers/#learn-more","title":"Learn more","text":"<p>Read more about working with controllers, requests, and responses:</p> <ul> <li>Requests</li> <li>Responses</li> <li>Building pages</li> </ul>"},{"location":"controllers/authentication/","title":"Authentication","text":"<p>Rwf has multiple authentication and authorization mechanisms. Different kinds of authentication require their own kinds of user-supplied credentials. The most commonly used mechanism is Session authentication, which has built-in methods for easy use in controllers.</p>"},{"location":"controllers/authentication/#session-authentication","title":"Session authentication","text":"<p>Session authentication checks that the user-supplied session cookie is valid (not expired) and contains an authenticated session. If that's not the case, the request is either rejected with a <code>401 - Unauthorized</code> or provided an endpoint to re-authenticate, e.g., using a username and password, with a <code>302 - Found</code> redirect.</p>"},{"location":"controllers/authentication/#enable-session-authentication","title":"Enable session authentication","text":"<p>To enable session authentication, it needs to be configured on the controller by implementing the <code>auth</code> method:</p> <pre><code>use rwf::prelude::*;\n\n/// A controller that requires authentication.\nstruct Private {\n    auth: AuthHandler,\n}\n\nimpl Default for Private {\n    fn default() -&gt; Self {\n        Private {\n            // Redirect unauthenitcated requests to the `/login` route.\n            auth: AuthHandler::new(\n                SessionAuth::redirect(\"/login\"),\n            ),\n        }\n    }\n}\n\n#[async_trait]\nimpl Controller for Private {\n    /// Enable authentication on this controller.\n    fn auth(&amp;self) -&gt; &amp;AuthHandler {\n        &amp;self.auth\n    }\n\n    /* ... */\n}\n</code></pre>"},{"location":"controllers/authentication/#basic-authentication","title":"Basic authentication","text":"<p>HTTP Basic is a form of authentication using a global username and password. It's not particularly secure, but it's good enough to protect an endpoint quickly against random visitors. Enabling basic authentication is as simple as setting an <code>AuthHandler</code> with <code>BasicAuth</code> on your controller. See examples/auth for examples on how to do this.</p>"},{"location":"controllers/cookies/","title":"Cookies","text":"<p>HTTP cookies are a special header that contains key/value-encoded information. Cookies are typically set on the server, and the client (like a browser) should store them on their end and send them with each subsequent request to the server.</p> <p>Cookies allow persisting information between what are otherwise stateless HTTP requests.</p>"},{"location":"controllers/cookies/#read-cookies","title":"Read cookies","text":"<p>Cookies sent by the browser can be read inside a controller by calling the <code>cookies</code> method:</p> <pre><code>let cookies = request.cookies();\n</code></pre> <p>Since cookies are encoded as key/value pairs, fetching a cookie value can be done by knowing its name:</p> <pre><code>let session_id = cookies.get(\"session_id\");\n\nif let Some(session_id) = session_id {\n    println!(\"session_id: {}\", session_id.value());\n}\n</code></pre> <p>More often than not, cookies are used to store plain text information, so no special decoding procedure is required to read the cookie value.</p>"},{"location":"controllers/cookies/#set-cookies","title":"Set cookies","text":"<p>Setting cookies on the server can be done when crafting a response:</p> <pre><code>use rwf::prelude::*;\n\nlet mut response = Response::new();\n\nlet cookie = CookieBuilder::new()\n    .name(\"session_id\")\n    .value(\"1234\")\n    .max_age(Duration::days(1))\n    .build();\n\nresponse\n    .cookies()\n    .add(cookie);\n</code></pre> <p>This produces a <code>Set-Cookie</code> header encoded with the cookie name, value, and other attributes like <code>MaxAge</code>. You can learn more about cookie attributes and their meaning on MDN.</p>"},{"location":"controllers/cookies/#private-cookies","title":"Private cookies","text":"<p>Private cookies are cookies that have been encrypted, so the client can't see their contents, or modify them, without the server detecting (and automatically rejecting) them. They are useful for storing sensitive information like a user's session, which can be used in later requests to authenticate requests.</p>"},{"location":"controllers/cookies/#set-private-cookies","title":"Set private cookies","text":"<p>Setting private cookies on the response works much like regular cookies, except instead of using <code>add</code>, you need to use <code>add_private</code>:</p> <pre><code>response\n    .cookies()\n    .add_private(cookie)?;\n</code></pre> <p>Cookies are encrypted with AES-128, using the security key set in the configuration.</p>"},{"location":"controllers/cookies/#read-private-cookies","title":"Read private cookies","text":"<p>Reading private cookies works much like regular cookies, except instead of using <code>get</code>, you need to use <code>get_private</code>:</p> <pre><code>let session_id = cookies.get_private(\"session_id\")?;\n</code></pre> <p>Decryption will be done automatically, and the controller will be able to access the plain text value of the cookie.</p>"},{"location":"controllers/custom-errors/","title":"Custom error pages","text":"<p>When a controller returns an HTTP error code higher than 399, like HTTP 404 or HTTP 500 for example, Rwf displays an error page. The default error page doesn't provide much information beyond the error code and name, so it's a good idea to use custom ones that would direct your users to helpful resources.</p>"},{"location":"controllers/custom-errors/#custom-404","title":"Custom 404","text":"<p>The most common error your users will run into is requesting a page that doesn't exist. Customizing this error message can be done by providing a catch-all (or wildcard) controller:</p> <pre><code>use rwf::prelude::*;\n\n#[derive(Default)]\nstruct NotFound;\n\n#[async_trait]\nimpl Controller for NotFound {\n    async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        render!(request, \"templates/404.html\")\n    }\n}\n</code></pre> <p>To configure the Rwf HTTP server to serve your custom <code>404.html</code> template, map your <code>NotFound</code> controller to the <code>/*</code> route, like so:</p> <pre><code>Server::new(vec![\n    // ... your other routes ...\n    NotFound::default().wildcard(\"/\"),\n]);\n</code></pre> <p>Wildcard routes have a low rank of -20. When matching requests to controllers, the HTTP server will attempt all other routes, and if none of them match, it will serve the wildcard route.</p> <p>Note</p> <p>If your controllers return HTTP 404 manually, the server will not use your wildcard route and will return the default error page instead. Universal catchers for error codes are on the roadmap.</p>"},{"location":"controllers/middleware/","title":"Middleware","text":"<p>Middleware runs before a request reaches a controller and has the ability to modify the request, or block it from reaching the controller entirely. Middleware is used to validate incoming requests against some conditions, e.g. required headers. It can also be used to mark requests with special tags, by adding custom headers.</p>"},{"location":"controllers/middleware/#using-middleware","title":"Using middleware","text":"<p>Middleware needs to be specified on each controller. By default, all controllers come with no middleware, so requests processed by them are unmodified from their original state.</p>"},{"location":"controllers/middleware/#define-middleware","title":"Define middleware","text":"<p>Middleware, similar to controllers, is any struct which implements the <code>Middleware</code> trait. The only method that needs implementation is the <code>async fn handle_request</code> method, which accepts a <code>Request</code> and must return an <code>Outcome</code>.</p> <p>If the request is allowed to proceed, <code>Outcome::Forward</code> is returned, containing the request, in its modified or unchanged form. If on the other hand, the request failed some kind of validation, <code>Outcome::Stop</code> must be returned with a <code>Response</code>, for example:</p> <pre><code>use rwf::controller::middleware::prelude::*;\n\nstruct RequiredHeaders {\n    headers: Vec&lt;String&gt;,\n}\n\nimpl Default for RequiredHeaders {\n    fn default() -&gt; Self {\n        Self {\n            headers: vec![\n                \"X-Request-Id\".to_string()\n            ],\n        }\n    }\n}\n\n#[async_trait]\nimpl Middleware for RequiredHeaders {\n    async fn handle_request(&amp;self, request: Request) -&gt; Result&lt;Outcome, Error&gt; {\n        for header in &amp;self.headers {\n            let header = request.headers().get(header);\n\n            if header.is_none() {\n                return Ok(Outcome::Stop(request, Response::bad_request()));\n            }\n        }\n\n        Ok(Outcome::Forward(request))\n    }\n}\n</code></pre>"},{"location":"controllers/middleware/#enable-middleware","title":"Enable middleware","text":"<p>Enabling middleware needs to be done at the controller level. For each controller where you want the middleware to run, add it to the struct fields and instantiate it when the controller is created:</p> <pre><code>struct Index {\n    middleware: MiddlewareSet,\n}\n\nimpl Default for Index {\n    fn default() -&gt; Self {\n        Index {\n            middleware: MiddlewareSet::new(vec![\n                RequiredHeaders::default()\n                    .middleware(),\n            ])\n        }\n    }\n}\n</code></pre> <p>When implementing the <code>Controller</code> trait for your controller, implement the <code>middleware</code> method as well:</p> <pre><code>#[async_trait]\nimpl Controller for Index {\n    // This controller has middleware.\n    fn middleware(&amp;self) -&gt; &amp;MiddlewareSet {\n        &amp;self.middleware\n    }\n\n    // Middleware will run before this method.\n    async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        /* ... */\n    }\n}\n</code></pre> <p>Adding a controller with middleware to the server requires no special code, since middleware is handled by the <code>Controller</code> trait internally.</p>"},{"location":"controllers/pages/","title":"Building pages","text":"<p>Typical navigation around a web app consist of <code>GET</code> requests that retrieve pages (generated with links or buttons) , and <code>POST</code> requests which submit new information and do something useful with it (using forms). <code>GET</code> and <code>POST</code> are the basic building blocks of any web app, and Rwf makes it easy to build pages with it.</p>"},{"location":"controllers/pages/#page-controller","title":"Page controller","text":"<p>The basic <code>Controller</code> doesn't disambiguate between <code>GET</code> and <code>POST</code> requests. If used for every page in your app, you end up having to write boilerplate code like this:</p> <pre><code>if request.get() {\n    // Retrive page\n} else if request.post() {\n    // Handle form submission\n} else {\n    return Ok(Response::not_allowed());\n}\n</code></pre> <p>To avoid doing this and cluttering your codebase, Rwf comes with the <code>PageController</code>. This controller trait implements the <code>GET</code>/<code>POST</code> split automatically and routes requests to two separate methods: <code>async fn get</code> and <code>async fn post</code>.</p> <p>Let's use the example of a login page built using the <code>PageController</code>:</p> <pre><code>use rwf::prelude::*;\n\n#[derive(Default, macros::PageController)]\nstruct Login;\n\nimpl PageController for Login {\n    // Handle GET and show the login form.\n    async fn get(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        render!(request, \"templates/login.html\")\n    }\n\n    // Handle POST, receive form data, check information, and\n    // redirect the logged in user to a different page.\n    async fn post(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        let form = request.form_data();\n\n        let email = form.get_required::&lt;String&gt;(\"email\");\n        let password = form.get_required::&lt;String&gt;(\"password\");\n\n        // Check that the user exists\n\n        Ok(Response::new().login(user.id).redirect(\"/account\"))\n    }\n}\n</code></pre> <p>The <code>async fn get</code> method renders the login form, while the <code>async fn post</code> takes care of the actual login process by handling the form submission via <code>POST</code>.</p> <p>Once you register this controller with the server, one route will handle <code>GET</code> and <code>POST</code> requests:</p> <pre><code>Server::new(vec![route!(\"/login\" =&gt; Login)])\n    .launch()\n    .await\n</code></pre>"},{"location":"controllers/pages/#note-on-macros","title":"Note on macros","text":"<p>Note</p> <p>If you're not particularly interested in how Rwf works under the hood, you can skip this section (at least for now).</p> <p>You may have noticed the odd <code>macros::PageController</code> macro in the login controller declaration. This macro expands to this:</p> <pre><code>impl Controller for Login {\n    async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        PageController::handle(self, request).await\n    }\n}\n</code></pre> <p>Rwf HTTP server can only serve controllers that implement the <code>Controller</code> trait, so all supertraits must implement it as well. <code>PageController</code> is a supertrait of <code>Controller</code> that actually implements the required <code>async fn handle</code> method from <code>Controller</code>, but due to how dynamic dispatch works in Rust, it has to be called manually from the \"child\"<sup>1</sup> trait.</p> <p>To avoid boilerplate code, the <code>macros::PageController</code> does this automatically.</p> <ol> <li> <p>Rust traits don't really work like child/parent classes in object-oriented programming, hence the \"air\" quotes.\u00a0\u21a9</p> </li> </ol>"},{"location":"controllers/request/","title":"Requests","text":"<p>For each HTTP request served by Rwf, a new <code>Request</code> struct is created. It contains the client IP address, browser headers, cookies, session information, and the request body.</p>"},{"location":"controllers/request/#headers","title":"Headers","text":"<p>Fetching headers sent by the client in the HTTP request can be done by calling the <code>headers</code> method on the request object inside a controller:</p> <pre><code>struct Index;\n\nimpl Controller for Index {\n    // Handle HTTP request.\n    async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        // Get the `Accept` header from the request.\n        let accept = request\n            .headers()\n            .get(\"accept\");\n\n        if let Some(accept) = accept {\n            Ok(Response::new().text(format!(\"Accept: {}\", accept)));\n        } else {\n            Ok(Response::bad_request())\n        }\n    }\n}\n</code></pre> <p>Note</p> <p>Headers in Rwf are case-insensitive, so <code>accept</code> and <code>Accept</code> are equivalent.</p> <p>Most browsers send required headers like <code>Origin</code>, <code>Accept</code>, and <code>User-Agent</code>, but that doesn't mean all HTTP clients will. Checking for valid headers is good practice to avoid bad actors like bots. Read more about intercepting HTTP requests with Middleware.</p>"},{"location":"controllers/request/#request-body","title":"Request body","text":"<p>For requests that include a body, like <code>POST</code> or <code>PUT</code>, the body can be read using multiple methods, depending on the expected content type.</p>"},{"location":"controllers/request/#forms","title":"Forms","text":"<p>HTTP forms submitted using <code>POST</code> (or <code>PUT</code>/<code>PATCH</code>) are encoded using either URL encoding or multipart encoding. Parsing the form data is automatically handled by Rwf, so accessing a form field can be done in a couple ways.</p>"},{"location":"controllers/request/#form-fields","title":"Form fields","text":"<pre><code>let form = request.form_data();\nlet email = form.get::&lt;String&gt;(\"email\");\n\nif let Some(email) = email {\n    // Create account.\n}\n</code></pre> <p>Form fields are converted to a Rust type manually, by passing in the data type to the generic <code>FormData::get</code> function. All data types that implement the <code>FromStr</code> trait are supported, including integers, floats, boolean, and UUIDs.</p>"},{"location":"controllers/request/#strictly-typed-forms","title":"Strictly-typed forms","text":"<p>Instead of parsing form fields manually on each request, you can define a Rust struct with the matching column names and data types to your form:</p> RustHTML <pre><code>#[derive(Debug, macros::Form)]\nstruct UserForm {\n    // required\n    email: String,\n    // required\n    password: String,\n    // optional\n    password2: Option&lt;String&gt;,\n}\n\nlet form = request.form::&lt;UserForm&gt;()?;\n\nif form.password2.is_none() {\n  return Ok(Response::bad_request());\n}\n</code></pre> <pre><code>&lt;form&gt;\n  &lt;input name=\"email\" type=\"text\" required&gt;\n  &lt;input name=\"password\" type=\"password\" required&gt;\n  &lt;input name=\"password2\" type=\"password\"&gt;\n&lt;/form&gt;\n</code></pre>"},{"location":"controllers/request/#files","title":"Files","text":"<p>Rwf supports file uploads using multipart form encoding. A POST request with <code>Content-Type: multipart/form-data</code> containing files can be retrieved by their input name:</p> RustHTML <pre><code>let form = request.form_data()?;\nlet file = form.file(\"file_upload\");\n\nif let Some(file) = file {\n    let bytes = file.bytes();\n    let name = file.name();\n}\n</code></pre> <pre><code>&lt;form method=\"post\" enctype=\"multipart/form-data\"&gt;\n  &lt;input type=\"file\" name=\"file_upload\"&gt;\n&lt;/form&gt;\n</code></pre> <p>Note</p> <p>Forms that wish to upload files need to have the <code>enctype=\"multipart/form-data\"</code> attribute. By default, HTML forms use <code>application/x-www-form-urlencoded</code> encoding which will omit any unsupported inputs like files.</p>"},{"location":"controllers/request/#json","title":"JSON","text":"<p>If the body is expected to be JSON, it can be read using the <code>json</code> method instead. The <code>json</code> method is generic and automatically converts the request body into a Rust struct using the <code>serde_json</code> crate:</p> RustJSON <pre><code>use serde::Deserialize;\n\n#[derive(Deserialize)]\nstruct User {\n    email: String,\n}\n\nlet user = request.json::&lt;User&gt;()?;\n</code></pre> <pre><code>{\n  \"email\": \"new-user@example.com\"\n}\n</code></pre>"},{"location":"controllers/request/#unstructured-json","title":"Unstructured JSON","text":"<p>If you don't know the schema of the JSON request, you can use <code>json_raw</code> instead, for example:</p> RustJSON <pre><code>let json = request.json_raw()?;\nprintln!(\"{}\", json[\"id\"]);\n</code></pre> <pre><code>{\n  \"id\": 5,\n  \"name\": \"New user\"\n}\n</code></pre>"},{"location":"controllers/request/#parsing-errors","title":"Parsing errors","text":"<p>If you use <code>FormData::get_required</code> or <code>Request::json</code> methods with the <code>?</code> operator, an error will be returned to the client automatically if the parsing of the form data fails. Unlike other controller errors that return <code>500 - Internal Server Error</code>, this type of error will return <code>400 - Bad Request</code>.</p>"},{"location":"controllers/request/#learn-more","title":"Learn more","text":"<ul> <li>examples/files</li> </ul>"},{"location":"controllers/response/","title":"Responses","text":"<p>Each HTTP request served by Rwf is expected to return a response. If your app is using a REST API, responses are typically JSON. If you prefer HTML over the wire or plain old websites, the responses will contain HTML or text.</p>"},{"location":"controllers/response/#creating-responses","title":"Creating responses","text":"<p>To create a response, you can just instantiate the <code>Response</code> struct and populate the body with the right content. The most popular response types have their own instantiation methods:</p> HTMLJSONPlain text <pre><code>let response = Response::new()\n  .html(\"&lt;h1&gt;Big letters!&lt;/h1&gt;\");\n</code></pre> <pre><code>let json = serde_json::json!({\n  \"id\": 5,\n  \"email\": \"test@example.com\"\n});\n\nlet response = Response::new().json(json)?;\n</code></pre> <pre><code>let response = Response::new()\n  .text(\"One apple a day keeps the doctor away!\");\n</code></pre> <p>Using one of those methods will automatically set the right <code>Content-Type</code> and <code>Content-Length</code> headers.</p>"},{"location":"controllers/response/#raw-data","title":"Raw data","text":"<p>If your endpoint is sending binary data or some data type we don't have a method for, you can always set the body and content type manually:</p> <pre><code>let mystery_bytes: Vec&lt;u8&gt; = vec![1, 1, 2, 3, 5, 8, 13];\n\nlet response = Response::new()\n  .body(mystery_bytes)\n  .header(\"Content-Type\", \"x-application/fibonacci\");\n</code></pre> <p>Note</p> <p><code>Response</code> attempts to deduce the <code>Content-Type</code> by the body type, so if you want to override its decision, set the header after setting the body on the response. By default, <code>Vec&lt;u8&gt;</code> uses the <code>Content-Type: application/octet-stream</code>.</p> <p>The <code>Content-Length</code> header is always set automatically, but if you absolutely need to, you can set it manually.</p>"},{"location":"controllers/response/#headers","title":"Headers","text":"<p>Setting custom headers can be done with the <code>header</code> method, for example:</p> <pre><code>let response = Response::new()\n  .header(\"X-My-Header\", \"My value\")\n  .header(\"Cache\", \"no-store\");\n</code></pre> <p>Headers are rewritten to lowercase lettering, i.e. <code>X-My-Header</code> and <code>x-my-header</code> are equivalent.</p>"},{"location":"controllers/response/#http-codes","title":"HTTP codes","text":"<p>A <code>Response</code> returns with HTTP code <code>200 - OK</code> by default. If you want to set a different code, you can:</p> <pre><code>let response = Response::new()\n    .html(\"&lt;h1&gt;Created!&lt;/h1&gt;\")\n    .code(201);\n</code></pre> <p>Common use cases have their own methods to make this easier.</p>"},{"location":"controllers/response/#redirect","title":"Redirect","text":"<p>Redirecting the user to a different URL can be done with:</p> <pre><code>let response = Response::new()\n    .redirect(\"/different-url\");\n</code></pre> <p>This automatically sets the <code>Location</code> and <code>Cache-Control</code> headers, and returns with HTTP code <code>302 - Found</code>.</p>"},{"location":"controllers/response/#errors","title":"Errors","text":"<p>Common errors have their own methods which will return the correct HTTP response code and built-in response body.</p>"},{"location":"controllers/response/#401-unauthorized","title":"401 - Unauthorized","text":"<p>When your users have failed some authentication challenge, you can block access to a resource with HTTP response code <code>401 - Unauthorized</code>:</p> <pre><code>let resonse = Response::unauthorized();\n</code></pre> <p>Use this one if your frontend can handle it gracefully. If not, a gentle redirect to your login page may be preferable.</p>"},{"location":"controllers/response/#403-forbidden","title":"403 - Forbidden","text":"<p>When your user is logged in, but doesn't have access to the request resource, you can block access to it with HTTP response code <code>403 - Forbidden</code>:</p> <pre><code>let resonse = Response::forbidden();\n</code></pre>"},{"location":"controllers/response/#404-not-found","title":"404 - Not found","text":"<p>Commonly used when some resource doesn't exist, HTTP response code <code>404 - Not Found</code> can be returned with:</p> <pre><code>let response = Response::not_found();\n</code></pre> <p>HTTP 404 is returned automatically by Rwf when a user requests a route that doesn't have a controller.</p>"},{"location":"controllers/response/#syntactic-sugar","title":"Syntactic sugar","text":"<p>Returning certain types of responses is common, so Rwf has a few automatic conversions to remove boilerplate from controllers. In the context of a controller method, the following statements are equivalent.</p>"},{"location":"controllers/response/#html","title":"HTML","text":"ShortcutCode <pre><code>\"&lt;h1&gt;Text&lt;/h1&gt;\".into()\n</code></pre> <pre><code>Response::new().html(\"&lt;h1&gt;Text&lt;/h1&gt;\")\n</code></pre>"},{"location":"controllers/response/#json","title":"JSON","text":"ShortcutCode <pre><code>serde_json::json!({\"hello\": \"world\"}).into()\n</code></pre> <pre><code>Response::new().json(serde_json::json!({\"hello\": \"world\"})?;\n</code></pre>"},{"location":"controllers/response/#learn-more","title":"Learn more","text":"<ul> <li>Cookies</li> <li>Sessions</li> </ul>"},{"location":"controllers/sessions/","title":"Sessions","text":"<p>A session is an encrypted cookie managed by Rwf. It contains a unique identifier for each browser using your web app. All standard-compliant browsers connecting to Rwf-powered apps will have a Rwf session set automatically, and should send it back on each request.</p>"},{"location":"controllers/sessions/#session-types","title":"Session types","text":"<p>Rwf has two kind of sessions: guest sessions and authenticated sessions. Guest sessions have a random alphanumeric identifier, while user sessions have a number identifier, meant to refer to a unique user ID in your database.</p> <p>When using sessions, you can distinguish between the two like so:</p> <pre><code>match request.session_id() {\n    SessionId::Guest(id) =&gt; { /* handle guest session */ }\n    SessionId::Authenticated(user_id) =&gt; { /* handle user session */ }\n}\n</code></pre>"},{"location":"controllers/sessions/#authenticate-user","title":"Authenticate user","text":"<p>To give a user an authenticated session, i.e. log them into your app, you can set the session cookie with the user ID on the response:</p> <pre><code>async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n    let response = request.login(1234);\n    Ok(response)\n}\n</code></pre>"},{"location":"controllers/sessions/#check-for-valid-session","title":"Check for valid session","text":"<p>All controllers can check for the presence of a valid session:</p> <pre><code>let valid = !request.session().expired();\n</code></pre> <p>Unless the session cookie is set and has been encrypted using the correct algorithm and secret key, calling <code>session</code> will return <code>None</code>.</p>"},{"location":"controllers/sessions/#expired-sessions","title":"Expired sessions","text":"<p>If the session is expired, it's advisable not to trust its point of origin. While the contents are guaranteed to be accurate, the browser sending the data has not been validated in several weeks (4 weeks, by default).</p>"},{"location":"controllers/sessions/#session-authentication","title":"Session authentication","text":"<p>Rwf can ensure all requests have valid and current (not expired) sessions. To enable this feature, enable the <code>SessionAuth</code> authentication on your controllers. Guest sessions will be refused access, while authenticated sessions will be allowed through.</p>"},{"location":"controllers/sessions/#store-data-in-session","title":"Store data in session","text":"<p>Rwf sessions allow you to privately store arbitrary JSON-encoded data. Since browsers place limits on cookie sizes, this data should be relatively small. To store some data in the session, you can set it on the response:</p> <pre><code>let session = Session::new(\n    serde_json::json!({\n        \"data\": \"secret_value\"\n    })\n);\n\nlet response = Response::new()\n  .set_session(session);\n</code></pre>"},{"location":"controllers/sessions/#renew-sessions","title":"Renew sessions","text":"<p>Sessions are automatically renewed on each request. This allows your active users to remain \"logged in\", while inactive ones would be redirected to a login page if session authentication is enabled.</p> <p>Expired sessions are not renewed, so a user holding an expired session will need to use an authentication controller to get a new valid session.</p>"},{"location":"controllers/static-files/","title":"Static files","text":"<p>Rwf comes with a static files server built-in. It will handle serving files out of any directory and will automatically return the right <code>Content-Type</code> header (also known as MIME), based on the file extension.</p>"},{"location":"controllers/static-files/#serve-static-files","title":"Serve static files","text":"<p>The static files server is just another controller, implemented internally. To add it to your app, you can add it to the server at startup:</p> <pre><code>use rwf::controller::StaticFiles;\nuse rwf::http::{Server, self};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), http::Error&gt; {\n    let server = Server::new(vec![\n        StaticFiles::serve(\"static\")?,\n    ])\n    .launch()\n    .await\n}\n</code></pre> <p>This example will serve all static files in the <code>static</code> directory under the <code>/static</code> route.</p>"},{"location":"controllers/websockets/","title":"WebSockets","text":"<p>Rwf comes with built-in WebSockets support, requiring no additional dependencies or configuration.</p>"},{"location":"controllers/websockets/#what-are-websockets","title":"What are WebSockets?","text":"<p>A WebSocket is a bidirectional communication protocol that allows browsers and servers to talk to each other. Unlike normal HTTP responses, which are only delivered when the client asks for them, WebSocket messages can be sent by the server at any time.</p> <p>This is useful for updating web apps in real-time, or sending push notifications when something important happens on the server, for example.</p>"},{"location":"controllers/websockets/#how-do-websockets-work","title":"How do WebSockets work?","text":"<p>A WebSocket connection is a TCP connection. It's established by sending a regular HTTP request with a special header. If the server supports WebSockets, like Rwf does, it responds with a special response and upgrades the connection to use the WebSocket protocol instead of HTTP.</p> <p>WebSockets allow both clients and servers to send text and binary data, both of which are supported.</p>"},{"location":"controllers/websockets/#writing-a-websocket-controller","title":"Writing a WebSocket controller","text":"<p>A WebSocket controller is any Rust struct that implements the <code>WebsocketController</code> trait.</p> <p>The trait has two methods of interest: the first handles new WebSocket connections, and the other incoming messages from the client.</p> <pre><code>use rwf::controller::Websocket;\nuse rwf::prelude::*;\n\n#[derive(Default, macros::WebsocketController)]\nstruct Echo;\n\n#[async_trait]\nimpl WebsocketController for Echo {\n    /// Run some code when a new client connects to the WebSocket server.\n    async fn handle_connection(\n        &amp;self,\n        client: &amp;SessionId,\n    ) -&gt; Result&lt;(), Error&gt; {\n        log::info!(\"Client {:?} connected to the echo server\", client);\n\n        Ok(())\n    }\n\n    /// Run some code when a client sends a message to the server.\n    async fn handle_message(\n        &amp;self,\n        client: &amp;SessionId,\n        message: Message,\n    ) -&gt; Result&lt;(), Error&gt; {\n        // Get an app-wide WebSocket channel to the client.\n        // This will send a message to the client via WebSocket\n        // connection from anywhere in the code.\n        let comms = Comms::websocket(client);\n\n        // Send the message back to the client (we're an echo server).\n        comms.send(message)?;\n\n        Ok(())\n    }\n}\n</code></pre> <p>There are a few things to unpack here. The <code>handle_message</code> method is called every time a client sends a message addressed to this WebSocket controller. What to do with the message depends on the application, but if we were writing a real-time chat app, we would save it to the database and notify all interested clients of a new message.</p> <p>The <code>Comms</code> struct is a global data structure that keeps track of who is connected to our server. You can use it to send a <code>Message</code> to any client at any time.</p> <p>Note</p> <p>The <code>macros::WebsocketController</code> automatically implements the <code>Controller</code> trait. All Rwf controllers have to implement the <code>Controller</code> trait, and the <code>WebsocketController</code> is no exception. The trait automatically implements the <code>handle</code> method, however due to the nature of Rust dynamic dispatch, the <code>handle</code> method of the supertrait has to be called explicitly in the base trait.</p> <p>If you were not to use the macro, you could do the same thing manually:</p> <pre><code>#[async_trait]\nimpl Controller for Echo {\n    async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        WebsocketController::handle(self, request).await\n    }\n}\n</code></pre>"},{"location":"controllers/websockets/#sending-messages-to-clients","title":"Sending messages to clients","text":"<p>All WebSocket clients have a unique session identifier. Sending a message to a client only requires that you know their session ID, which you can obtain from the <code>Request</code>, for example:</p> <pre><code>let session_id = request.session_id();\nlet websocket = Comms::websocket(&amp;session_id);\n\nwebsocket.send(\"hey there\")?;\n</code></pre> <p>WebSocket messages can be delivered to any client from anywhere in the application, including controllers and background jobs.</p>"},{"location":"controllers/websockets/#starting-a-websocket-server","title":"Starting a WebSocket server","text":"<p>Since WebSockets are built into Rwf, you can just add the controller to the server at startup:</p> <pre><code>use rwf::prelude::*;\nuse rwf::http::{Server, self};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), http::Error&gt; {\n    let server = Server::new(vec![\n        route!(\"/websocket\" =&gt; Echo),\n    ])\n    .launch()\n    .await\n}\n</code></pre>"},{"location":"controllers/websockets/#testing-the-connection","title":"Testing the connection","text":"<p>In a browser of your choice, open up the developer tools console and connect to the WebSocket server:</p> <pre><code>const ws = new WebSocket(\"ws://localhost:8000/websocket\");\n</code></pre> <p>If everything works, you should see a log line in the terminal where the server is running, indicating a new client has joined the party.</p>"},{"location":"controllers/REST/","title":"REST overview","text":"<p>REST (Representational State Transfer) is a design pattern for web applications that separates frontend and backend interactions into six (6) predefined operations, called REST verbs. RESTful apps use those verbs to fetch and change application state.</p>"},{"location":"controllers/REST/#six-methods","title":"Six methods","text":""},{"location":"controllers/REST/#list","title":"List","text":"<p>The list method, implemented using the HTTP <code>GET /endpoint</code> call, is meant to produce a list of resources found at a particular endpoint. For example, if you have a <code>/users</code> endpoint, executing <code>GET /users</code> should return a list of users visible to the user making the request:</p> RequestResponse <pre><code>curl localhost:8000/users\n</code></pre> <pre><code>[\n  {\"id\": 1, \"email\": \"admin@example.com\", \"admin\": true},\n  {\"id\": 2, \"email\": \"first-user@example.com\", \"admin\": false}\n]\n</code></pre>"},{"location":"controllers/REST/#get","title":"Get","text":"<p>The get method, implemented using the HTTP <code>GET /endpoint/&lt;id&gt;</code> call, where <code>&lt;id&gt;</code> is a unique resource identifier, e.g., a number or a UUID, fetches one specific resource found at this endpoint and which has the provided identifier. For example, if the client requests the <code>/users/1</code> resource, the framework would return one <code>User</code> object with the primary key <code>1</code>:</p> RequestResponse <pre><code>curl localhost:8000/users/1\n</code></pre> <pre><code>{\n  \"id\": 1,\n  \"email\": \"admin@example.com\",\n  \"admin\": false\n}\n</code></pre>"},{"location":"controllers/REST/#create","title":"Create","text":"<p>Create, implemented using the HTTP <code>POST /endpoint</code> call, creates a new resource at that endpoint. The caller specifies the resource definition, which the server needs to validate, and will return the resource created, along with any server-generated fields like the unique resource identifier.</p> <p>Taking the <code>/users</code> endpoint example, executing <code>POST /users</code> would create a new user in the application:</p> RequestResponse <pre><code>curl localhost:8000/users \\\n  -d '{\"email\": \"alice@example.com\", \"admin\": false}'\n</code></pre> <pre><code>{\n  \"id\": 45,\n  \"email\": \"alice@example.com\",\n  \"admin\" false\n}\n</code></pre>"},{"location":"controllers/REST/#update","title":"Update","text":"<p>The update method, implemented using the HTTP <code>PUT /endpoint/&lt;id&gt;</code> call, updates an existing resource with new values, and returns the updated resource:</p> RequestResponse <pre><code>curl -X PUT localhost:8000/users/45 \\\n  -d '{\"email\": \"alice1@example.com\", \"admin\": false}'\n</code></pre> <pre><code>{\n  \"id\": 45,\n  \"email\": \"alice1@example.com\",\n  \"admin\": false\n}\n</code></pre>"},{"location":"controllers/REST/#patch","title":"Patch","text":"<p>The patch method, implemented using the HTTP <code>PATCH /endpoint/&lt;id&gt;</code> call, performs a partial update of the resource, allowing the caller to send only the fields in the resource object that should be changed:</p> RequestResponse <pre><code>curl -X PATCH localhost:8000/users/45 -d '{\"admin\": true}'\n</code></pre> <pre><code>{\n  \"id\": 45,\n  \"email\": \"alice1@example.com\",\n  \"admin\": true\n}\n</code></pre>"},{"location":"controllers/REST/#delete","title":"Delete","text":"<p>The delete method, implemented using the HTTP <code>DELETE /endpoint/&lt;id&gt;</code> call, deletes a resource:</p> RequestResponse <pre><code>curl -X DELETE localhost:8000/users/45\n</code></pre> <pre><code>(empty)\n</code></pre>"},{"location":"controllers/REST/#rest-controller","title":"REST controller","text":"<p>Rwf comes with a REST controller, which has the six aforementioned methods separated into individual functions. For example, writing a <code>/users</code> endpoint controller could be done like so:</p> <pre><code>use rwf::prelude::*;\n\n#[derive(Default, macros::RestController)]\nstruct Users;\n\n#[async_trait]\nimpl RestController for Users {\n    // Users controller uses the primary key to identify resources.\n    type Resource = i64;\n\n    /// List all users.\n    /// \"GET /users\"\n    async fn list(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        let users = serde_json::json!([\n            {\"id\": 1, \"email\": \"admin@example.com\", \"admin\": true},\n            {\"id\": 2, \"email\": \"alice@example.com\", \"admin\": false},\n        ]);\n\n        Ok(Response::new().json(users)?)\n    }\n\n    /// Get a particular user by identifier.\n    /// \"GET /users/&lt;id&gt;\"\n    async fn get(&amp;self, request: &amp;Request, id: &amp;i64) -&gt; Result&lt;Response, Error&gt; {\n        let user = serde_json::json!({\n            \"id\": *id,\n            \"email\": \"admin@example.com\",\n            \"admin\": true\n        });\n\n        Ok(Response::new().json(user)?)\n    }\n\n    /* Optionally implement other REST methods */\n}\n</code></pre> <p>The <code>RestController</code> has all six methods (list, get, update, patch, create, delete) and automatically splits the traffic based on the request path and HTTP method used. Implementing any of them is optional. If you don't implement it, the framework will return HTTP 405 <code>Method Not Allowed</code>.</p>"},{"location":"controllers/REST/#resource-identifier","title":"Resource identifier","text":"<p>When implementing the controller, you need to specify the data type used as the identifier for your resources. Example above uses <code>i64</code>, which when converted to the database datatype becomes <code>BIGINT</code> (or <code>BIGSERIAL</code>), but any data types are supported, for example:</p> <pre><code>type Resource = String;\n</code></pre> <p>The identifier data type only needs to implement the <code>ToParameter</code> trait.</p>"},{"location":"controllers/REST/#connecting-to-a-route","title":"Connecting to a route","text":"<p>When launching your server, add your REST controllers to the server routes using the <code>rest!</code> macro (instead of the usual <code>route!</code>), for example:</p> <pre><code>use rwf::prelude::*;\nuse rwf::http::Server;\n\n#[tokio::main]\nasync fn main() {\n    Server::new(vec![\n        rest!(\"/users\" =&gt; Users),\n    ])\n    .launch()\n    .await\n    .unwrap()\n}\n</code></pre> <p>The <code>rest!</code> macro will ensure that all six REST-style paths are sent to the <code>Users</code> controller.</p> <p>Note</p> <p>The <code>rest!</code> macro translates to <code>Users::default().rest(\"/users\")</code>. The <code>Users</code> struct should implement the <code>Default</code> trait for this to work. You don't have to use the macro and can connect a controller to the server manually.</p>"},{"location":"controllers/REST/#learn-more","title":"Learn more","text":"<ul> <li>Model controller</li> <li>examples/rest</li> </ul>"},{"location":"controllers/REST/model-controller/","title":"Model controller","text":"<p>It's common for applications that use REST with the ORM to translate the six REST verbs into four data operations, called CRUD: Create. Read, Update, and Delete. This allows frontend code to directly manipulate backend models, shifting most of the application logic to JavaScript frameworks like React or Vue.</p> <p>To avoid writing boilerplate code, Rwf provides the <code>ModelController</code> which matches the REST verbs to CRUD operations automatically:</p> <pre><code>use rwf::prelude::*;\nuse serde::{Serialize, Deserialize};\n\n/// The model.\n#[derive(Clone, macros::Model, Serialize, Deserialize)]\nstruct User {\n    id: Option&lt;i64&gt;,\n    email: String,\n}\n\n/// The controller.\n#[derive(Default, macros::ModelController)]\nstruct Users;\n\n#[async_trait]\nimpl ModelController for Users {\n    type Model = User;\n\n    /* All methods are implemented automatically. */\n}\n</code></pre>"},{"location":"controllers/REST/model-controller/#connecting-to-a-route","title":"Connecting to a route","text":"<p>To add a CRUD controller to the server, you can use the <code>crud!</code> macro, for example:</p> <pre><code>use rwf::prelude::*;\nuse rwf::http::Server;\n\n#[tokio::main]\nasync fn main() {\n    Server::new(vec![\n        crud!(\"/users\" =&gt; Users),\n    ])\n    .launch()\n    .await\n    .unwrap()\n}\n</code></pre> <p>Note</p> <p>Just like the <code>rest!</code> and <code>route!</code> macros, the <code>crud!</code> macro is optional. It translates to <code>Users::default().crud(\"/users\")</code> which can be written manually if special initialization for the controller is required.</p>"},{"location":"controllers/REST/model-controller/#using-the-controller","title":"Using the controller","text":"<p>Frontend code can directly fetch, create and modify resources using the controller, for example:</p> List usersOutputUpdate userOutput <pre><code>let response = await fetch(\"/users\");\nconst users = await response.json();\n\nconsole.log(users)\n</code></pre> <pre><code>[\n  {\"id\": 1, \"email\": \"admin@example.com\", \"admin\": true},\n  {\"id\": 2, \"email\": \"alice1@example.com\", \"admin\": false}\n]\n</code></pre> <pre><code>let response = await fetch(\"/users/2\", {\n  method: \"PATCH\",\n  body: JSON.stringify({admin: true}),\n});\n\nconst user = await response.json();\n\nconsole.log(user)\n</code></pre> <pre><code>{\"id\": 2, \"email\": \"alice1@example.com\", \"admin\": true}\n</code></pre>"},{"location":"controllers/REST/model-controller/#pagination","title":"Pagination","text":"<p>To avoid excessive data transfer and slow database queries, the model controller uses pagination on the list endpoint. Resources are returned in pages of 25 items each. You can paginate between them by passing the <code>page</code> query parameter, for example:</p> <pre><code>GET /users?page=5\n</code></pre> <p>To control the page size, pass the <code>page_size</code> query parameter, for example:</p> <pre><code>GET /users?page=1&amp;page_size=50\n</code></pre>"},{"location":"controllers/REST/model-controller/#json-serialization","title":"JSON serialization","text":"<p>The model controller uses JSON serialization powered by the <code>serde_json</code> crate. When implementing the <code>ModelController</code> for a model, make sure to derive the <code>Serialize</code> and <code>Deserialize</code> traits.</p> <p><code>serde</code> is very flexible and allows you to control every aspect of serialization and deserialization. You can rename, hide, overwrite, and ignore any model fields. See Field attributes for more information on how to customize JSON (de)serialization.</p>"},{"location":"controllers/REST/model-controller/#learn-more","title":"Learn more","text":"<ul> <li>examples/rest</li> <li>Serde field attributes</li> </ul>"},{"location":"models/","title":"ORM basics","text":""},{"location":"models/#introduction","title":"Introduction","text":"<p>Rwf comes with its own ORM (object-relational mapping). The Rwf ORM is very flexible, supporting anything from basic fetch by primary key queries, to multi-table joins and complex custom queries.</p>"},{"location":"models/#whats-an-orm","title":"What's an ORM?","text":"<p>The ORM is the M in MVC design: the model. It allows to easily retrieve data stored in your database tables and display it in the application, without having to write complex SQL queries by hand.</p> <p>It works by attaching itself to Rust structs and mapping data from table columns to struct fields (and vice versa), converting them from database types to Rust data types automatically in the process.</p>"},{"location":"models/#getting-started","title":"Getting started","text":"<p>Using the ORM is simple and only requires defining a struct for each model (or database table). For example, most web apps will have a <code>User</code> model, which stores its data in a <code>\"users\"</code> table:</p> Column Database data type Rust data type <code>id</code> <code>BIGINT</code> <code>i64</code> <code>email</code> <code>VARCHAR</code> <code>String</code> <code>created_at</code> <code>TIMESTAMPTZ</code> <code>time::OffsetDateTime</code> <p>Defining the Rust struct for the model can be done as follows:</p> <pre><code>use rwf::prelude::*;\n\n#[derive(Clone, macros::Model)]\nstruct User {\n    id: Option&lt;i64&gt;,\n    email: String,\n    created_at: OffsetDateTime,\n}\n</code></pre> <p>The same table in the database can be created with this query<sup>1</sup>:</p> <pre><code>CREATE TABLE users (\n  id BIGSERIAL PRIMARY KEY,\n  email VARCHAR NOT NULL,\n  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n</code></pre> <p>Note</p> <p>The <code>id</code> column is using an optional Rust <code>i64</code> integer. This is because the struct will be used for both inserting and selecting data from the table. When inserting, the <code>id</code> column should be <code>None</code> and will be automatically assigned by the database. This ensures that all rows in your tables have a unique primary key.</p>"},{"location":"models/#naming-conventions","title":"Naming conventions","text":"<p>The struct fields have the same name as the database columns, and the data types match their respective Rust types. The table name in the database corresponds to the name of the struct, lowercase and pluralized. For example, <code>User</code> model will refer to the <code>\"users\"</code> table in the database.</p> <p>A row in a database table which contains model data is called a record. The <code>macros::Model</code> macro automatically implements the database to Rust and vice versa types conversion and maps the column values to the struct fields.</p>"},{"location":"models/#query-data","title":"Query data","text":"<p>With the model defined in Rust, writing SQL queries is automatically implemented by the ORM. For example, to fetch a record by primary key, you can do the following:</p> <pre><code>let user = User::find(15)\n    .fetch(&amp;mut conn)\n    .await?;\n</code></pre> <p>The <code>find</code> method is implemented by the <code>Model</code> trait for the <code>User</code> struct automatically. It accepts a Rust integer and produces the following query:</p> <pre><code>SELECT * FROM \"users\" WHERE id = $1\n</code></pre> <p>The <code>fetch</code> method assembles the query, sends it to the database, and returns one row. The row is converted to an instance of the <code>User</code> struct:</p> <pre><code>println!(\"user email: {}\", user.email);\n</code></pre>"},{"location":"models/#fetch-multiple-rows","title":"Fetch multiple rows","text":"<p>Querying multiple rows can be done by using <code>fetch_all</code> instead of <code>fetch</code>, for example:</p> <pre><code>let users = User::all()\n    .order(\"id\")\n    .limit(25)\n    .fetch_all(&amp;mut conn)\n    .await?;\n</code></pre> <p>This will fetch 25 user records from the <code>\"users\"</code> table, ordering them by the primary key. The result will be a <code>Vec&lt;User&gt;</code>, in the order returned by the database:</p> <pre><code>for user in &amp;users {\n    println!(\"{}: {}\", user.id, user.email);\n}\n</code></pre> <p>The ORM can be used to write easy and complex queries alike, without having to learn SQL. Rwf currently supports PostgreSQL, but other databases like SQLite and MySQL are on the roadmap.</p> <ol> <li> <p>See migrations to learn how to create tables in your database reliably.\u00a0\u21a9</p> </li> </ol>"},{"location":"models/connection-pool/","title":"Connection pool","text":"<p>Rwf manages database connections automatically. Since Rwf apps are multi-threaded and asynchronous, a typical deployment will require multiple connections to the database to support concurrent requests. The connection pool takes care of creating and closing connections, and providing them to to the app as needed.</p>"},{"location":"models/connection-pool/#get-a-connection","title":"Get a connection","text":"<p>To execute queries with the ORM, you'll need to check out a connection from the pool. You can do so as follows from anywhere in the code:</p> <pre><code>let mut conn = Pool::connection().await?;\n</code></pre> <p>Once you have a connection, you can pass it to the ORM each time you need to execute a query:</p> <pre><code>let users = User::all()\n    .fetch_all(&amp;mut conn)\n    .await?;\n</code></pre>"},{"location":"models/connection-pool/#return-connection-to-the-pool","title":"Return connection to the pool","text":"<p>Returning the connection to the pool is done automatically when the <code>conn</code> variable goes out of scope. In Rust semantics, the <code>conn</code> variable is \"dropped\". For example, to checkout a connection for only one query, you can do so inside its own scope:</p> <pre><code>let users = {\n    let mut conn = Pool::connection().await?;\n    User::all()\n        .fetch_all(&amp;mut conn)\n        .await?\n};\n</code></pre>"},{"location":"models/connection-pool/#transactions","title":"Transactions","text":"<p>All queries are executed inside their own implicit transactions by default. If you need to execute multiple queries inside a single transaction, you need to start one explicitly:</p> <pre><code>let mut transaction = Pool::transaction().await?;\n</code></pre> <p>The transaction follows the same scope semantics as a pool connection. When it goes out scope, the transaction is automatically rolled back and the connection is returned back to the pool. If you want to commit any changes you made inside the transaction, you need to call <code>commit</code> explicitly:</p> <pre><code>transaction.commit().await?;\n</code></pre> <p>Automatic rollbacks are a safety feature of Rwf connection management. In case an error happens in Rust mid-transaction, the changes are automatically reverted, preventing partial updates to the database.</p> <p>Just like a connection, the transaction can be passed to any query generated with the ORM:</p> <pre><code>let user = User::find(15)\n    .fetch_one(&amp;mut transaction)\n    .await?;\n</code></pre>"},{"location":"models/connection-pool/#waiting-for-connections","title":"Waiting for connections","text":"<p>When all available connections are checked out, the call to <code>Pool::connection()</code> will wait (and asynchronously block) until a connection is returned to the pool. If a connection is not returned in time, a timeout error will be returned, unblocking the request and allowing it to handle the situation gracefully.</p>"},{"location":"models/create-records/","title":"Create records","text":"<p>Rwf can create model records in one of two ways:</p> <ul> <li><code>Model::save</code> method which is called on an instance of a struct implementing the <code>Model</code> trait</li> <li><code>Model::create</code> method which accepts the column names and their respective values as input</li> </ul>"},{"location":"models/create-records/#saving-models","title":"Saving models","text":"<p>Using our <code>User</code> model from our previous example, we can create a new record by instantiating a new instance of the <code>User</code> struct and calling <code>save</code>:</p> <pre><code>let user = User {\n    id: None,\n    email: \"admin@example.com\".to_string(),\n    created_at: OffsetDateTime::now_utc(),\n};\n\nlet user = user\n    .save()\n    .fetch(&amp;mut conn)\n    .await?;\n</code></pre> <p>Note</p> <p>The <code>id</code> field is set to <code>None</code>. This ensures that the database assigns it a value automatically, and that this value is unique.</p> <p>Calling <code>save</code> on a model struct with the <code>id</code> set to <code>None</code> produces the following query:</p> <pre><code>INSERT INTO \"users\" (\"email\", \"created_at\") VALUES ($1, $2) RETURNING *\n</code></pre>"},{"location":"models/create-records/#using-table-defaults","title":"Using table defaults","text":"<p>If you don't want to specify some columns when creating records and your database schema has configured defaults, you can use the <code>Model::create</code> method instead:</p> RustSQL <pre><code>let user = User::create(&amp;[\n    (\"email\", \"admin@example.com\"),\n])\n.fetch(&amp;mut conn)\n.await?\n</code></pre> <pre><code>INSERT INTO \"users\" (\"email\") VALUES ($1) RETURNING *\n</code></pre> <p>Any columns not specified in the <code>INSERT</code> statement will be automatically filled in with column defaults. For example, the <code>created_at</code> column specified in our previous example has a default value <code>NOW()</code>, the current database time.</p>"},{"location":"models/create-records/#mixing-data-types","title":"Mixing data types","text":"<p>When using <code>Model::create</code>, Rwf automatically converts values from Rust to database types. Due to how Rust works, it's not possible to build slices containing values of different types. If you try, you will get <code>error[E0308]: mismatched types</code>. To get around this, you can call <code>ToValue::to_value</code> on each column, for example:</p> RustSQL <pre><code>let user = User::create(&amp;[\n    (\"email\", \"user@example.com\".to_value()),\n    (\"created_at\", OffsetDateTime::now_utc().to_value()),\n])\n.fetch(&amp;mut conn)\n.await?;\n</code></pre> <pre><code>INSERT INTO \"users\" (\"email\", \"created_at\") VALUES ($1, $2) RETURNING *\n</code></pre>"},{"location":"models/create-records/#unique-constraints","title":"Unique constraints","text":"<p>It's very common to place unique constraints on certain columns in a table to avoid duplicate records. For example, the <code>\"users\"</code> table would typically have a unique constraint on the <code>email</code> column, ensuring that no two users have the same email address.</p> <p>To handle unique constraints, Rwf can update a record in-place if one exists already matching the constraint:</p> RustSQL <pre><code>let user = User::create(&amp;[\n  (\"email\", \"admin@example.com\")\n])\n.unique_by(&amp;[\"email\"])\n.fetch(&amp;mut conn)\n.await?;\n</code></pre> <pre><code>INSERT INTO \"users\" (\"email\") VALUES ($1)\nON CONFLICT (\"email\") DO UPDATE\nSET \"email\" = EXCLUDED.\"email\"\nRETURNING *\n</code></pre>"},{"location":"models/create-records/#optionally-create-records","title":"Optionally create records","text":"<p>If the record matching the <code>INSERT</code> statement exists already, Rwf supports returning the existing row without performing an update:</p> RustSQL <pre><code>let user = User::find_or_create_by(&amp;[\n  (\"email\", \"user1@example.com\")\n])\n.fetch(&amp;mut conn)\n.await?;\n</code></pre> <pre><code>SELECT * FROM \"users\" WHERE \"email\" = $1;\nINSERT INTO \"users\" (\"email\") VALUES ($1) RETURNING *;\n</code></pre> <p>This executes up to two queries, starting with a <code>SELECT</code> to see if a row already exists, and if it doesn't, an <code>INSERT</code> to create it.</p>"},{"location":"models/create-records/#combining-with-a-unique-constraint","title":"Combining with a unique constraint","text":"<p>In busy web apps which execute thousands of queries per second, it's entirely possible for a record to be created between the time the <code>SELECT</code> query returns no rows and an <code>INSERT</code> query is sent to the database. In this case, a unique constraint violation error will be returned. To avoid this, it's possible to combine <code>unque_by</code> with <code>find_or_create_by</code> executed inside a single transaction:</p> RustSQL <pre><code>// Start a transaction explicitely.\nlet transaction = Pool::transaction().await?;\n\nlet user = User::find_or_create_by(&amp;[\n  (\"email\", \"user1@example.com\")\n])\n.unique_by(&amp;[\"email\"])\n.fetch(&amp;mut transaction)\n.await?;\n\n// Commit the transaction.\ntransaction.commit().await?;\n</code></pre> <p>A transaction is started explicitly: <pre><code>BEGIN\n</code></pre></p> <p>Afterwards, the ORM attempts to find a record matching the columns in the <code>INSERT</code> statement:</p> <pre><code>SELECT * FROM \"users\" WHERE \"email\" = $1\n</code></pre> <p>If this query returns a row, no more queries are executed. Otherwise, an <code>INSERT</code> query with <code>ON CONFLICT</code> clause is sent to the database:</p> <pre><code>INSERT INTO \"users\" (\"email\") VALUES ($1)\nON CONFLICT (\"email\") DO UPDATE\nSET \"email\" = EXCLUDED.\"email\"\nRETURNING *\n</code></pre> <p>Finally, the transaction is committed to the database:</p> <pre><code>COMMIT\n</code></pre>"},{"location":"models/custom-queries/","title":"Custom queries","text":"<p>Sometimes the ORM is not enough and you need to write a complex query by hand. Rwf provides an easy way to execute arbitrary queries and map the results to a model struct:</p> <pre><code>let users = User::find_by_sql(\n    \"SELECT * FROM users ORDER BY RANDOM() LIMIT 1\",\n    &amp;[]\n)\n  .fetch_all(&amp;mut conn)\n  .await?;\n</code></pre> <p>Note</p> <p>Since this query is not generated by the ORM, you need to make sure to return all the necessary columns and correct data types to map the results to the Rust struct.</p>"},{"location":"models/custom-queries/#passing-parameters","title":"Passing parameters","text":"<p>Custom queries accept parameters just like any other ORM query. Postgres uses the dollar notation (<code>$1</code>) for value placeholders, for example:</p> <pre><code>let users = User::find_by_sql(\n    \"SELECT * FROM users\n    WHERE id BETWEEN $1 AND $2\n    ORDER BY RANDOM()\",\n    &amp;[25, 50],\n).fetch_all(&amp;mut conn)\n.await?;\n</code></pre> <p>Make sure the parameter values are passed in the same order as the placeholders in the query.</p>"},{"location":"models/custom-queries/#use-the-database-driver-directly","title":"Use the database driver directly","text":"<p>If you want to bypass the ORM entirely and just execute queries, you can do so by checking out a connection and calling the <code>query_cached</code> method on it:</p> <pre><code>let mut conn = Pool::connection().await?;\n\nlet results = conn\n    .query_cached(\"SELECT * FROM wherever WHERE column = $1\", &amp;[5])\n    .await?;\n</code></pre> <p>Rwf uses <code>tokio_postgres</code> underneath to talk to Postgres, so you'll receive a <code>Vec&lt;tokio_postgres::Row&gt;</code> as a result of executing that function.</p> <p>Since <code>tokio_postgres</code> uses prepared statements, <code>query_cached</code> ensures that identical queries are not prepared more than once per connection. If you want to bypass that and use <code>tokio_postgres</code> directly, you can use <code>client()</code> instead:</p> <pre><code>let mut conn = Pool::connection().await?;\n\n// Returns a `tokio_postgres::Client`\nlet client = conn.client();\n\nclient\n    .execute(\"SELECT 1\", &amp;[])\n    .await?;\n</code></pre>"},{"location":"models/customize-attributes/","title":"Customize attributes","text":"<p>When defining models, the <code>Model</code> macro makes certain assumptions about your database table and column names. For example, the name of the table is derived from the struct name:</p> <pre><code>#[derive(Clone, macros::Model)]\nstruct User {\n    id: Option&lt;i64&gt;,\n}\n</code></pre> <p>The name of the struct, <code>User</code> is lowercased and pluralized, to derive the table name <code>\"users\"</code>. Similarly, the foreign key for the <code>\"users\"</code> table is derived to be <code>\"user_id\"</code>.</p> <p>It's possible to override this behavior, by specifying both table name and foreign key names manually:</p> <pre><code>#[derive(Clone, macros::Model)]\n#[table_name(\"my_user_table\")]\n#[foreign_key(\"u_id\")]\nstruct User {\n    id: Option&lt;i64&gt;,\n}\n</code></pre>"},{"location":"models/debug-queries/","title":"Debug queries","text":"<p>When building queries using the ORM, the end result can be inspected by calling <code>to_sql()</code>:</p> RustOutput <pre><code>let query = User::all()\n  .filter(\"created_at\", Value::Null)\n  .limit(5)\n  .to_sql();\nprintln!(\"Query: {}\", query);\n</code></pre> <pre><code>Query: SELECT * FROM \"users\" WHERE \"created_at\" IS NULL LIMIT 5\n</code></pre> <p>The query will not be sent to the database, so it's safe to inspect all queries, no matter if they are performant or not.</p>"},{"location":"models/debug-queries/#query-plan","title":"Query plan","text":"<p>Visual inspection of the query is often not sufficient to understand query performance. For this purpose, databases like PostgreSQL provide the <code>EXPLAIN</code> functionality which, instead of executing the query, produces an execution plan:</p> RustSQLOutput <pre><code>let plan = User::find(15)\n  .explain(&amp;mut conn)\n  .await?;\nprintln!(\"{}\", plan);\n</code></pre> <pre><code>EXPLAIN SELECT * FROM \"users\" WHERE \"id\" = $1\n</code></pre> <pre><code>Seq Scan on users  (cost=0.00..25.00 rows=6 width=40)\nFilter: (id = 5)\n</code></pre> <p>When optimizing queries, this functionality is useful for finding queries that should be using indexes but perform a sequential scan instead.</p>"},{"location":"models/fetch-records/","title":"Fetch records","text":""},{"location":"models/fetch-records/#retrieve-by-primary-key","title":"Retrieve by primary key","text":"<p>Retrieving a record by primary key method accepts an integer and returns a single row corresponding to where the value of the <code>id</code> column equals to the integer:</p> RustSQL <pre><code>let user = User::find(15)\n    .fetch(&amp;mut conn)\n    .await?\n\nassert_eq!(user.id, 15);\n</code></pre> <pre><code>SELECT * FROM \"users\" WHERE \"id\" = $1\n</code></pre>"},{"location":"models/fetch-records/#searching-records","title":"Searching records","text":"<p>Rwf supports searching records by any column in its respective table. For example, the <code>User</code> model has three columns, all of which are searchable:</p> RustSQLPlaceholders <pre><code>use time::Duration;\n\nlet users = User::all()\n  .filter(\"email\", \"admin@example.com\")\n  .filter_gte(\"created_at\", OffsetDateTime::now_utc() - Duration::hours(1))\n  .fetch_all(&amp;mut conn)\n  .await?\n\nassert_eq!(users.len(), 1);\n</code></pre> <pre><code>SELECT * FROM \"users\" WHERE \"email\" = $1 AND \"created_at\" &gt;= $2\n</code></pre> ID Value <code>$1</code> <code>'admin@example.com'</code> <code>$2</code> <code>'2024-10-16T11:27:56-07:00'</code> <p>Rwf supports multiple comparison operations for most data types:</p> Method Operator Example <code>filter</code> <code>=</code> <code>id = 5</code> <code>not</code> / <code>filter_not</code> <code>!=</code> <code>email != 'user@example.com'</code> <code>filter_gt</code> <code>&gt;</code> <code>created_at &gt; NOW()</code> <code>filter_lt</code> <code>&lt;</code> <code>created_at &lt; '2024-10-16'</code> <code>filter_gte</code> <code>&gt;=</code> <code>id &gt;= 5</code> <code>filter_lte</code> <code>&lt;=</code> <code>id &lt;= 25</code> <code>filter</code> <code>IN</code> <code>id IN (1, 2, 3)</code> <code>not</code> <code>NOT IN</code> <code>id NOT IN (4, 5, 6)</code> <p>The <code>filter</code> (and <code>not</code>) methods accept lists of values (in Rust, those are called \"slices\") which translate to the <code>IN</code> and <code>NOT IN</code> filters in SQL respectively:</p> RustSQL <pre><code>let users = User::all()\n  .filter(\"email\", &amp;[\"user1@example.com\", \"user2@example.com\"])\n  .fetch_all(&amp;mut conn)\n  .await?;\n\nassert_eq(users.len(), 2);\n</code></pre> <pre><code>SELECT * FROM \"users\" WHERE \"email\" = ANY($1)\n</code></pre> <p>Note</p> <p><code>= ANY('{1, 2, 3}')</code> is equivalent to <code>IN (1, 2, 3)</code>. In fact, when performing an index scan using an <code>IN</code> (or <code>NOT IN</code>) clause, the query is translated by the database to use <code>ANY</code> instead.</p>"},{"location":"models/fetch-records/#search-by-null","title":"Search by <code>NULL</code>","text":"<p>Searching columns that have no value, i.e. the value is <code>NULL</code>, is a special case and is handled by passing the <code>Value::Null</code> explicitly:</p> RustSQL <pre><code>let users = User::all()\n  .filter(\"email\", Value::Null)\n  .fetch_all(&amp;mut conn)\n  .await?;\n\nassert_eq!(users.len(), 0);\n</code></pre> <pre><code>SELECT * FROM \"users\" WHERE \"email\" IS NULL\n</code></pre> <p>Searching by the opposite, where a column is not <code>NULL</code>:</p> RustSQL <pre><code>let users = User::all()\n  .not(\"email\", Value::Null)\n  .count(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT COUNT(*) FROM \"users\" WHERE email IS NOT NULL\n</code></pre>"},{"location":"models/fetch-records/#optional-results","title":"Optional results","text":"<p>When using <code>fetch</code>, if no rows exist, the ORM will return a <code>RecordNotFound</code> error. To avoid this, use <code>fetch_optional</code> which will return an <code>Option</code> instead:</p> RustSQL <pre><code>let user = User::all()\n  .take_one()\n  .fetch_optional(&amp;mut conn)\n  .await?;\n\nassert!(user.is_some());\n</code></pre> <pre><code>SELECT * FROM \"users\" LIMIT 1\n</code></pre>"},{"location":"models/fetch-records/#limiting-results","title":"Limiting results","text":"<p>Fetching many records at once can be inefficient and slow. To limit how many rows your queries return, you can add a <code>LIMIT</code> clause:</p> RustSQL <pre><code>let first_25 = User::all()\n  .limit(25)\n  .order(\"id\")\n  .fetch_all(&amp;mut conn)\n  .await?;\n\nassert_eq!(first_25.len(), 25);\n</code></pre> <pre><code>SELECT * FROM \"users\" ORDER BY \"id\" LIMIT 25\n</code></pre>"},{"location":"models/fetch-records/#paginating-results","title":"Paginating results","text":"<p>Pagination is supported using the <code>OFFSET</code> clause:</p> RustSQL <pre><code>let next_25 = User::all()\n  .limit(25)\n  .offset(25)\n  .order(\"id\")\n  .fetch_all(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT * FROM \"users\" ORDER BY \"id\" LIMIT 25 OFFSET 25\n</code></pre>"},{"location":"models/fetch-records/#ordering-results","title":"Ordering results","text":"<p>It's often more efficient and simpler to order rows in the database instead of in the application. Rwf supports ordering by any column in the query, by specifying them using the <code>order</code> method:</p> RustSQL <pre><code>let users = User::all()\n  .order(\"email\")\n  .order((\"id\", \"DESC\"))\n  .fetch_all(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT * FROM \"users\" ORDER BY \"email\", \"id\" DESC\n</code></pre>"},{"location":"models/fetch-records/#locking-rows","title":"Locking rows","text":"<p>In busy production applications, it's common for the same row to be accessed from multiple places at the same time. If you'd like to prevent that row from being accessed while you're doing something to it, for example updating it with new values, you can use a row-level lock:</p> RustSQL <pre><code>let transaction = Pool::transaction().await?;\n\nlet user = User::find(15)\n    .lock()\n    .fetch(&amp;mut transaction)\n    .await?;\n\ntransaction.commit().await?;\n</code></pre> <pre><code>BEGIN;\nSELECT * FROM \"users\" WHERE \"id\" = $1 FOR UPDATE;\nCOMMIT;\n</code></pre> <p>The lock on the row(s) returned by a query last only for the duration of the transaction. It's common to use that time to update multiple tables that have some kind of relationship to the row being locked. This mechanism allows to perform atomic operations (all or nothing) in a concurrent environment without data races or inconsistencies.</p>"},{"location":"models/grouping/","title":"Group by","text":"<p>Group by queries allow you to perform analysis of your data directly inside the database. They typically don't return original records, but some kind of aggregate instead. For example, the query below calculates how many users are creating accounts every hour:</p> SQLOutput <pre><code>SELECT\n    COUNT(*) AS count,\n    DATE_TRUNC('hour', created_at) AS created_at\nFROM users\nGROUP BY 2\nORDER BY 2\n</code></pre> <pre><code> count |       created_at\n-------+------------------------\n     1 | 2024-11-04 08:00:00-08\n     5 | 2024-11-04 09:00:00-08\n    17 | 2024-11-04 10:00:00-08\n</code></pre>"},{"location":"models/grouping/#write-a-group-by","title":"Write a group by","text":"<p>Ergonomic support for group by queries in Rwf is still a work in progress, so for now, you'll need to use custom queries.</p>"},{"location":"models/grouping/#define-a-struct","title":"Define a struct","text":"<p>Since Rust is a typed language, it would be best to define a struct for your aggregate. Using the example above, we can create a model like so:</p> <pre><code>#[derive(Clone, macros::Model)]\nstruct UsersPerHour {\n    count: i64,\n    created_at: OffsetDateTime,\n}\n</code></pre> <p>Using the <code>Model</code> macro allows this struct use all ORM features, just like regular models. In fact, any query result can be mapped to a model in Rwf, as long as you define a struct for it.</p>"},{"location":"models/grouping/#calculate-aggregate","title":"Calculate aggregate","text":"<p>Calculating the aggregate using the database can be done with <code>Model::find_by_sql</code>, for example:</p> <pre><code>let stats = UsersPerHour::find_by_sql(\"\n    SELECT\n        COUNT(*) AS count,\n        DATE_TRUNC('hour', created_at) AS created_at\n    FROM users\n    GROUP BY 2\n    ORDER BY 2\n\", &amp;[])\n.fetch_all(&amp;mut conn)\n.await?;\n</code></pre> <p>Just like with custom queries, make sure the query returns all columns specified by the struct, with the correct data types.</p>"},{"location":"models/grouping/#learn-more","title":"Learn more","text":"<ul> <li>Group by in rwf-admin</li> </ul>"},{"location":"models/join-models/","title":"Join models","text":"<p>Joining models together allows to build complex search queries spanning multiple database tables. Rwf supports joining models out of the box, but requires a couple of annotations to declare relationships between models.</p>"},{"location":"models/join-models/#define-model-relationship","title":"Define model relationship","text":"<p>Using the <code>User</code> model from our previous example, let's define a <code>Project</code> model, which will record projects created by the users of our fictional web app:</p> <pre><code>#[derive(Clone, macros::Model)]\n#[belongs_to(User)]\nstruct Project {\n    id: Option&lt;i64&gt;,\n    user_id: i64,\n    project_name: f64,\n    completed: bool,\n}\n</code></pre> <p>A few things to unpack here. First, a new macro annotation <code>belongs_to</code> indicates the type of relationship this model has to the <code>User</code> model. In this case, it indicates a \"belongs to\" relationship, meaning each instance of the <code>Project</code> model will have one <code>User</code> associated to it.</p> <p>If we were to create a table for storing records of this model, the query could be:</p> <pre><code>CREATE TABLE projects (\n  id BIGSERIAL PRIMARY KEY,\n  user_id BIGINT NOT NULL REFERENCES users(id),\n  project_name VARCHAR NOT NULL,\n  completed BOOLEAN NOT NULL\n);\n</code></pre>"},{"location":"models/join-models/#naming-convention","title":"Naming convention","text":"<p>The naming convention for foreign keys is the singular form of the table name its referring to, e.g. <code>users</code> becomes <code>user</code>, joined with the name of the primary key, in our case, the <code>id</code> column, producing the <code>user_id</code> foreign key.</p>"},{"location":"models/join-models/#join-tables","title":"Join tables","text":"<p>Specifying the <code>belongs_to</code> relationship allows us to query the <code>Project</code> model and join it to the <code>User</code> model easily:</p> RustSQL <pre><code>let projects = Project::all()\n  .join::&lt;User&gt;()\n  .filter(\"project_name\", \"My first Rwf web app\")\n  .filter(\"email\", \"user@example.com\")\n  .fetch_all(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT \"projects\".* FROM \"projects\"\nINNER JOIN \"users\" ON \"projects\".\"user_id\" = \"users\".\"id\"\nWHERE \"project_name\" = $1 AND \"email\" = $2\n</code></pre> <p>Note</p> <p>The <code>join::&lt;Model&gt;</code> method accepts a generic argument specifying which model we are joining to. If the association between <code>Project</code> and <code>User</code> doesn't exist, the Rust compiler will return an error. This helps us avoid common errors by accidentally joining tables that don't have a relationship.</p>"},{"location":"models/join-models/#disambiguating-fields","title":"Disambiguating fields","text":"<p>More often than not, two tables have columns with the same name. The most obvious example of this is the primary key, the <code>id</code> column by default, which exists in all Rwf models. To specify which table &amp; column a query is referring to, Rwf provides the ability to fully qualify the column with the table name:</p> RustSQL <pre><code>let projects = Project::all()\n  .join::&lt;User&gt;()\n  .filter(User::column(\"id\"), 5)\n  .take_one()\n  .fetch(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT * FROM \"projects\"\nINNER JOIN \"users\" ON \"projects\".\"user_id\" = \"users\".\"id\"\nWHERE \"users\".\"id\" = $1\nLIMIT 1\n</code></pre>"},{"location":"models/join-models/#inverse-relationship","title":"Inverse relationship","text":"<p>The <code>Project</code> model defines a <code>belongs_to</code> relationship to the <code>User</code> model, but the <code>User</code> model doesn't define one to the <code>Project</code> model. If we attempt to join <code>\"users\"</code> to <code>\"projects\"</code> (instead of the other way around), we will get a Rust compiler error. To avoid this, we can specify the inverse relationship on the <code>User</code> model, like so:</p> <pre><code>#[derive(Clone, macros::Model)]\n#[has_many(Project)]\nstruct User {\n    id: Option&lt;i64&gt;,\n    email: String,\n    created_at: OffsetDateTime,\n}\n</code></pre> <p>Joining <code>\"users\"</code> to <code>\"projects\"</code> now is possible and can produce interesting queries, for example:</p> RustSQL <pre><code>let beginners = User::all()\n  .join::&lt;Project&gt;()\n  .filter(\"project_name\", \"Rust Programming Language: Introduction\")\n  .filter(\"completed\", false)\n  .fetch_all(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT \"users\".* FROM \"users\"\nINNER JOIN \"projects\" ON \"users\".\"id\" = \"projects\".\"user_id\"\nWHERE \"project_name\" = $1 AND \"completed_at\" = $2\n</code></pre>"},{"location":"models/join-models/#additional-relationships","title":"Additional relationships","text":"<p><code>belongs_to</code> and <code>has_many</code> are the most common relationships, but it's possible to define more. For example, the \"has one\" relationship where one row in a table has only one row related to it in another table is a common relationship which doesn't have its own macro annotation.</p> <p>To implement this relationship, specify the <code>belongs_to</code> relationship, and add a <code>UNIQUE</code> constraint on the foreign key referring to that table. For example, if we wanted to allow the users of our fictional web app to have only one project, we can enforce this by altering the <code>\"projects\"</code> table:</p> <pre><code>ALTER TABLE \"projects\" ALTER COLUMN \"user_id\" UNIQUE;\n</code></pre> <p>This creates a unique index on that column, so if a user attempts to create a second project, the database will return an error.</p>"},{"location":"models/join-models/#joining-multiple-tables","title":"Joining multiple tables","text":"<p>Joining across multiple tables is possible as long as there exists at least one relationship between all tables in the query. For example, if we had another model called <code>Goal</code> which belongs to a <code>Project</code>, we would be able to join <code>\"users\"</code> to <code>\"goals\"</code> by going through <code>\"projects\"</code> first:</p> <pre><code>#[derive(Clone, macros::Model)]\n#[belongs_to(Project)]\nstruct Goal {\n    id: Option&lt;i64&gt;,\n    project_id: i64,\n    priority: i64,\n    goal_name: String,\n    achived: bool,\n}\n\n#[derive(Clone, macros::Model)]\n#[has_many(Goal)]\nstruct Project { /* ... */ }\n</code></pre> <p>The join will have to use the <code>join_nested</code> function instead, since <code>User</code> isn't directly related to <code>Goal</code>:</p> RustSQL <pre><code>let users = User::all()\n    .join_nested(Project::join::&lt;Goal&gt;())\n    .filter(\"goal_name\", \"Learn a lot\")\n    .fetch_all(&amp;mut conn)\n    .await?;\n</code></pre> <pre><code>SELECT \"users\".* FROM \"users\"\nINNER JOIN \"projects\" ON \"projects\".\"user_id\" = \"users\".\"id\"\nINNER JOIN \"goals\" ON \"goals\".\"project_id\" = \"projects\".\"id\"\nWHERE \"goal_name\" = $1\n</code></pre>"},{"location":"models/migrations/","title":"Migrations","text":"<p>Migrations are a systematic way of changing your database schema. They allow to add/remove/change database tables in a predictable and ordered way, and to make sure all versions of your database, in development and in production, have the same schema.</p> <p>Rwf supports migrations out of the box. To use this feature, install Rwf CLI, if you haven't already:</p> <pre><code>cargo install rwf-cli\n</code></pre> <p>The CLI should be available globally. You can check if it's working correctly by running:</p> CommandOutput <pre><code>rwf-cli --help\n</code></pre> <pre><code>Rust Web Framework CLI\n\nUsage: rwf-cli &lt;COMMAND&gt;\n\nCommands:\n  migrate  Manage migrations\n  setup    Setup the project for Rwf\n  help     Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n</code></pre>"},{"location":"models/migrations/#run-migrations","title":"Run migrations","text":"<p>If it's your first time setting up a Rwf app, you should run migrations before starting the server. To run migrations, change directory to the project root (where <code>Cargo.toml</code> is located) and run:</p> <pre><code>rwf-cli migrate run\n</code></pre> <p>This command will automatically read all files in the <code>migrations</code> folder, and run the necessary ones in the correct order. For instance, if a migration is already applied to your database, Rwf will skip it and run the next one.</p>"},{"location":"models/migrations/#create-new-migration","title":"Create new migration","text":"<p>If you're looking to change your database schema, e.g. by adding a new table, you can do so in a reproducible way with a migration. To create a new migration, run the following command:</p> CommandOutput <pre><code>rwf-cli migrate add --name \"&lt;migration name&gt;\"\n</code></pre> <pre><code>created \"migrations/1729119889028371278_unnamed.up.sql\"\ncreated \"migrations/1729119889028371278_unnamed.down.sql\"\n</code></pre> <p>Migrations are placed inside the <code>&lt;PROJECT_ROOT&gt;/migrations</code> folder. If this folder doesn't exist, <code>rwf-cli</code> will create it automatically.</p> <p>The migration name is optional. By default the migration will be \"unnamed\", but it's nice to name it something recognizable; this helps others working on your project (including future you) to know what was changed.</p>"},{"location":"models/migrations/#writing-migrations","title":"Writing migrations","text":"<p>The <code>migrate add</code> command creates two files in the <code>migrations</code> folder: the \"up\" migration and the \"down\" migration. The \"up\" migration contains the desired changes to the database schema, while the \"down\" migration contains commands to revert those changes.</p> <p>Note</p> <p>Having the \"down\" migration is technically optional but is very helpful in case the migration doesn't work in production, and you need to revert your changes and try again. Additionally, without the correct \"down\" migration, commands like <code>migrate flush</code> won't work correctly.</p> <p>For example, if you want to add a <code>\"users\"</code> table to your database, you can write the following migration:</p> Up migrationDown migration <pre><code>CREATE TABLE users (\n    id BIGSERIAL PRIMARY KEY,\n    email VARCHAR UNIQUE NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n</code></pre> <pre><code>DROP TABLE users;\n</code></pre> <p>Once finished, applying the migration can be done by running the <code>migrate run</code> command:</p> CommandOutput <pre><code>rwf-cli migrate run\n</code></pre> <pre><code>migration \"1729119889028371278_unnamed\" applied\n</code></pre>"},{"location":"models/migrations/#revert-migration","title":"Revert migration","text":"<p>If something went wrong, or you'd like to make more changes without creating another migration (in development), you can revert the last migration by running:</p> CommandOutput <pre><code>rwf-cli migrate revert\n</code></pre> <pre><code>migration \"1729119889028371278_unnamed\" reverted\n</code></pre> <p>The <code>revert</code> command automatically executes the \"down\" file for the last migration. If you'd like to revert more than one migration, specify the version to which you want to revert to, by passing the <code>--version &lt;VERSION&gt;</code> argument.</p> <p>Re-running the last migration can be done by running <code>migrate run</code> command again.</p>"},{"location":"models/migrations/#flush-the-database","title":"Flush the database","text":"<p>In local development, it's sometimes useful to delete everything in your database and start again. To do so, you can run the <code>migrate flush</code> command. This command will revert all migrations in reverse order, and re-apply them in normal order again.</p> <p>Warning</p> <p>Running <code>rwf-cli migrate flush</code> will delete all your data. Never run this command in production. To protect against accidental misuse, the command will not do anything unless a <code>--yes</code> flag is passed to it.</p>"},{"location":"models/scopes/","title":"Scopes","text":"<p>A scope, in ORM language, is a commonly used query which can be saved and re-used in different parts of the code without having to type it out multiple times.</p>"},{"location":"models/scopes/#declare-scopes","title":"Declare scopes","text":"<p>Rwf provides the <code>Scope&lt;Model&gt;</code> generic type which indicates that the value is a non-executed query. It's possible to declare scopes directly on the model struct (or as a separate function anywhere else), for example:</p> <pre><code>impl User {\n    fn admins() -&gt; Scope&lt;User&gt; {\n        User::all()\n            .filter(\"email\", &amp;[\n                \"admin@example.com\",\n                \"boss@example.com\",\n                \"joe@example.com\",\n            ])\n    }\n}\n</code></pre> <p>The query is now re-usable anywhere in the code base:</p> <pre><code>let admins = User::admins()\n    .fetch_all(&amp;mut conn)\n    .await?;\n</code></pre> <p>Note</p> <p>When defining scopes, it's important not to execute the scope before returning it. In the example above, you'll note that we don't call <code>fetch</code>, or <code>fetch_all</code> but return the result of calling <code>filter</code> instead.</p>"},{"location":"models/scopes/#chain-scopes","title":"Chain scopes","text":"<p>It's possible to build very complex queries easily, by chaining multiple scopes together:</p> <pre><code>impl User {\n    /// Admins created in the last hour.\n    fn new_admins() -&gt; Scope&lt;User&gt; {\n        User::admins()\n            .filter_gte(\n                \"created_at\",\n                OffsetDateTime::now_utc() - Duration::hours(1),\n            )\n    }\n\n    /// New admins ordered by primary key.\n    fn new_admins_ordered() -&gt; Scope&lt;User&gt; {\n        User::new_admins()\n            .order(\"id\")\n    }\n}\n</code></pre>"},{"location":"models/scopes/#scopes-and-joins","title":"Scopes and joins","text":"<p>It's entirely possible to save complex joins in a scope, for example:</p> <pre><code>impl User {\n    /// Users who understand how to write Rust macros.\n    fn intermediate() -&gt; Scope&lt;User&gt; {\n        User::all()\n          .join::&lt;Project&gt;\n          .filter(\"project_name\", \"How to write Rust macros\")\n          .filter(\"completed\", true)\n    }\n}\n</code></pre>"},{"location":"models/security/","title":"Security","text":"<p>The ORM is a common place in a web app where malicious users attempt to inject bad data in order to extract information they should not have access to or to damage the web app in some way, by deleting important data for example.</p> <p>To protect against what we call SQL injection attacks<sup>1</sup>, the Rwf ORM takes multiple precautions.</p>"},{"location":"models/security/#prepared-statements","title":"Prepared statements","text":"<p>Rwf uses prepared statements which separate the query text from user-specified values. The values themselves cannot be injected into the query, so the most common type of SQL injection attack becomes hard to impossible to execute.</p> <p>You'll note that all of our SQL examples use placeholders, values starting with the <code>$</code> sign, to indicate where values should go. The placeholders are replaced by the database once both the query text and the values are received, so malicious values can never leak into the query language itself.</p>"},{"location":"models/security/#escaping-user-supplied-values","title":"Escaping user-supplied values","text":"<p>For other values like column names, Rwf escapes them in order to avoid modifying queries in unexpected ways.</p> RustSQLError <pre><code>let oops = User::all()\n  .filter(\"\\\";DROP TABLE users;\", 5)\n  .fetch(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>SELECT * FROM \"users\" WHERE \"\"\";DROP TABLE users;\" = $1;\n</code></pre> <pre><code>ERROR:  column \"\";DROP TABLE users;\" does not exist\n</code></pre> <ol> <li> <p>A SQL injection attack is injecting custom SQL into a query, in order to extract data from database tables.\u00a0\u21a9</p> </li> </ol>"},{"location":"models/update-records/","title":"Update records","text":"<p>Rwf allows to update records using two mechanisms:</p> <ul> <li>Update a single record by calling <code>Model::save</code> on an instance of a model</li> <li>Update multiple records using one query by using <code>Model::update_all</code></li> </ul>"},{"location":"models/update-records/#update-a-single-record","title":"Update a single record","text":"<p>Updating a single record can be done by mutating struct instance fields and calling <code>save</code>:</p> RustSQL <pre><code>// Get an instance of a User model\nlet user = User::all()\n  .take_one()\n  .fetch(&amp;mut conn)\n  .await?;\n\n// Change a field\nuser.created_at = OffsetDateTime::now_utc();\n\n// Update the record\nlet user = user\n  .save()\n  .fetch(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>UPDATE \"users\" SET \"email\" = $1, \"created_at\" = $2 WHERE \"id\" = $3 RETURNING *\n</code></pre> <p>Instead of fetching the record from the database, you can just instantiate one manually, as long as you know the desired primary key value:</p> <pre><code>let user = User {\n  id: Some(25),\n  email: \"new_email@example.com\",\n  created_at: OffsetDateTime::now_utc(),\n};\n\nlet user = user\n  .save()\n  .fetch(&amp;mut conn)\n  .await?;\n</code></pre> <p>This is very similar to creating new records, except that we set the <code>id</code> field to a known value. When the <code>id</code> is set to <code>Some(i64)</code>, Rwf assumes the record exists in the database, meanwhile if the <code>id</code> is <code>None</code>, Rwf will attempt to create one instead.</p>"},{"location":"models/update-records/#update-multiple-records","title":"Update multiple records","text":"<p>Updating multiple records in one query is possible by searching for them first and then calling <code>update_all</code>:</p> RustSQL <pre><code>let users = User::all()\n  .filter_gte(\"created_at\", OffsetDateTime::now_utc() - Duration::hours(1))\n  .update_all(&amp;[\n    (\"created_at\", OfssetDateTime::now_utc()),\n  ])\n  .fetch_all(&amp;mut conn)\n  .await?;\n</code></pre> <pre><code>UPDATE \"users\" SET created_at = $1 WHERE created_at &gt;= $2\n</code></pre>"},{"location":"security/CSRF/","title":"CSRF protection","text":"<p>Cross-site request forgery<sup>1</sup> (or CSRF) is a type of attack which uses your website's forms to trick the user into submitting data to your application from somewhere else. Rwf comes with middleware to protect your application against such attacks.</p>"},{"location":"security/CSRF/#enable-csrf-protection","title":"Enable CSRF protection","text":"<p>CSRF protection is enabled by default. When users make <code>POST</code>, <code>PUT</code>, and <code>PATCH</code> requests to your app, Rwf will check for the presence of a CSRF token. If the token is not there, or has expired, the request will be blocked and <code>HTTP 400 - Bad Request</code> response will be returned.</p>"},{"location":"security/CSRF/#passing-the-token","title":"Passing the token","text":"<p>The CSRF token can be passed using one of two methods:</p> <ul> <li><code>X-CSRF-Token</code> HTTP header</li> <li><code>&lt;input name=\"rwf_csrf_token\" type=\"hidden\"&gt;</code> inside a form</li> </ul> <p>If you're submitting a form, you can add the <code>rwf_csrf_token</code> input automatically:</p> <pre><code>&lt;form method=\"post\" action=\"/login\"&gt;\n    &lt;%= csrf_token() %&gt;\n&lt;/form&gt;\n</code></pre> <p>If you're making AJAX requests (using <code>fetch</code>, for example), you can pass the token via the header. If you're using Stimulus (which comes standard with Rwf), you can pass the token via a data attribute to the Stimulus controller:</p> HTMLJavaScript <pre><code>&lt;div\n  data-controller=\"login\"\n  data-csrf-token=\"&lt;%= csrf_token_raw() %&gt;\"\n&gt;\n  &lt;!-- ... --&gt;\n&lt;/div&gt;\n</code></pre> <pre><code>import { Controller } from \"hotwired/stimulus\"\n\nexport default class LoginController extends Controller {\n\n  // Send request with CSRF token included.\n  sendRequest() {\n    const csrfToken = this.element.dataset.csrfToken;\n\n    fetch(\"/login\", {\n      headers: {\n        \"X-CSRF-Token\": csrfToken,\n      }\n    })\n  }\n\n}\n</code></pre>"},{"location":"security/CSRF/#disable-csrf-protection","title":"Disable CSRF protection","text":"<p>If you want to disable CSRF protection, you can do so globally by toggling the <code>csrf_protection</code> configuration option to <code>false</code>, or on the controller level by implementing the <code>fn skip_csrf(&amp;self)</code> method:</p> <pre><code>use rwf::prelude::*;\n\n#[derive(Default)]\nstruct IndexController;\n\nimpl Controller for IndexController {\n    /// Disable CSRF protection for this controller.\n    fn skip_csrf(&amp;self) -&gt; bool {\n        true\n    }\n\n    /* ... */\n}\n</code></pre>"},{"location":"security/CSRF/#rest","title":"REST","text":"<p>If you're using JavaScript frameworks like React or Vue for your frontend, it's common to disable CSRF protection on your REST controllers. To do so, you can add the <code>#[skip_csrf]</code> attribute to your <code>ModelController</code>, for example:</p> <pre><code>#[derive(macros::ModelController)]\n#[skip_csrf]\nstruct Users;\n</code></pre> <p>You can always disable CSRF globally via configuration and enable it only on the controllers that serve HTML forms.</p>"},{"location":"security/CSRF/#token-validity","title":"Token validity","text":"<p>The CSRF token is valid for the same duration as Rwf sessions. By default, this is set to 4 weeks. A new token is generated every time your users load a page which contains a token generated with the built-in template functions.</p>"},{"location":"security/CSRF/#wsgi-rack-controllers","title":"WSGI / Rack controllers","text":"<p>Rwf CSRF protection is disabled for Python and Rails applications. It's expected that Django/Flask/Rails applications will use their own CSRF protection middleware.</p> <ol> <li> <p>https://en.wikipedia.org/wiki/Cross-site_request_forgery \u21a9</p> </li> </ol>"},{"location":"security/encryption/","title":"Encryption","text":"<p>Rwf uses AES-128 for encrypting user sessions and private cookies. The same functionality is available through the <code>rwf::crypto</code> module to encrypt and decrypt arbitrary data.</p>"},{"location":"security/encryption/#encrypt-data","title":"Encrypt data","text":"<p>To encrypt data using AES-128 and the application secret key, you can use the <code>encrypt</code> function, for example:</p> <pre><code>use rwf::crypto::encrypt;\n\nlet data = serde_json::json!({\n    \"user\": \"test\",\n    \"password\": \"hunter2\"\n});\n\n// JSON is converted into a byte array.\nlet data = serde_json::to_vec(&amp;data).unwrap();\n\n// Data is encrypted with AES.\nlet encrypted = encrypt(&amp;data).unwrap();\n</code></pre> <p>Any kind of data can be encrypted, as long as it's serializable to an array of bytes. Serialization can typically be achieved by using <code>serde</code>.</p> <p>Encryption produces a base64-encoded UTF-8 string. You can save this string in the database or send it via an insecure medium like email.</p>"},{"location":"security/encryption/#decrypt-data","title":"Decrypt data","text":"<p>To decrypt the data, you can call the <code>decrypt</code> function on the string produced by the <code>encrypt</code> function. The decryption algorithm will automatically convert the base64-encoded string to bytes and decrypt those bytes using the secret key, for example:</p> <pre><code>use rwf::crypto::decrypt;\n\nlet decrypted = decrypt(&amp;encrypted).unwrap();\nlet json = serde_json::from_slice(&amp;decrypted).unwrap();\n\nassert_eq!(json[\"user\"], \"test\");\n</code></pre>"},{"location":"security/hashing/","title":"Password hashing","text":"<p>Password hashing is a technique for storing and validating user passwords without exposing what those passwords are. All modern web apps must use this technique to store credentials, and Rwf comes with built-in support for hashing using Argon2.</p>"},{"location":"security/hashing/#generate-hashes","title":"Generate hashes","text":"<p>A password hash can be generated using the <code>rwf::crypto::hash</code> function, for example:</p> <pre><code>use rwf::crypto::hash;\n\nlet hashed = hash(\"secret_password\".as_bytes()).unwrap();\n</code></pre> <p>The hash generated by this function is a Rust string; it can be saved in a database. Since Argon2 is cryptographically secure, strong passwords are reasonably protected against brute force attacks in case the hashes are leaked.</p> <p>Note</p> <p>While hashes are hard to brute force, it's still inadvisable to allow hashes to be easily accessible to anyone. Make every effort to protect your production database against unauthorized access.</p>"},{"location":"security/hashing/#validate-passwords","title":"Validate passwords","text":"<p>Hashes are used to check that some information the application has seen previously matches what the it's seeing now. For example, when one of your users wants to log into the application, they will provide the application with a login and a password. The password can be validated against an existing hash, and if the two match, it's safe to assume that the password is correct.</p> <p>Passwords can be validated using the <code>rwf::crypto::hash_validate</code> function, for example:</p> <pre><code>use rwf::crypto::hash_validate;\n\nlet matches = hash_validate(\n    \"secret_password\".as_bytes(),\n    &amp;hashed,\n).unwrap();\n</code></pre>"},{"location":"security/hashing/#using-with-tokio","title":"Using with Tokio","text":"<p>You'll note that both <code>hash</code> and <code>hash_validate</code> functions are slow. In fact, it can take upwards a second to generate or validate a hash. This is done on purpose, to make hashes hard to brute force. To avoid blocking the Tokio runtime and slowing down your application, make sure to use both functions inside blocking tasks:</p> <pre><code>use tokio::task::spawn_blocking;\n\nlet hashed = spawn_blocking(move || {\n    hash(\"secret_password\".as_bytes())\n})\n.await\n.unwrap()\n.unwrap();\n</code></pre>"},{"location":"security/hashing/#learn-more","title":"Learn more","text":"<ul> <li>examples/users</li> </ul>"},{"location":"user-guides/","title":"Local dev overview","text":"<p>Local development with Rwf benefits from the extensive Rust ecosystem, and makes some additions of its own, like hot reloading of frontend code.</p> <p>To make your development experience smoother, we recommend you install <code>cargo-watch</code> and <code>cargo-nextest</code>, like so:</p> <pre><code>cargo install cargo-watch cargo-nextest\n</code></pre>"},{"location":"user-guides/#watch-for-changes","title":"Watch for changes","text":"<p><code>cargo-watch</code> can monitor your code for changes and restart the server automatically. This makes local development much easier: as you make edits to your code, you don't have to stop and start the server manually:</p> <pre><code>cargo watch --exec run\n</code></pre>"},{"location":"user-guides/#hot-reload","title":"Hot reload","text":"<p>Rwf can refresh pages automatically as they are being changed. If you enable hot reload, and also use <code>cargo-watch</code>, make sure to tell it to ignore template changes:</p> <pre><code>cargo watch --exec run --ignore \"*.html\"\n</code></pre>"},{"location":"user-guides/#run-tests","title":"Run tests","text":"<p>Running tests with <code>cargo-nextest</code> is faster and more ergonomic as opposed to using built-in <code>cargo test</code>. If you end up writing tests for your app, you can run them all in parallel:</p> <pre><code>cargo nextest run\n</code></pre>"},{"location":"user-guides/#learn-more","title":"Learn more","text":"<ul> <li>Hot reload</li> </ul>"},{"location":"user-guides/admin/","title":"Admin panel","text":"<p>Rwf comes with its own admin panel which provides a real time overview of web activity, insights into the background jobs queue, and allows to manipulate database models.</p> <p>The admin panel is written with Rwf and can be included into any Rwf-powered application.</p>"},{"location":"user-guides/admin/#enable-the-admin-panel","title":"Enable the admin panel","text":"<p>The admin panel comes in its own crate: <code>rwf-admin</code>. To enable it, add it to your application dependencies:</p> <pre><code>cargo add rwf-admin\n</code></pre>"},{"location":"user-guides/admin/#preload-templates","title":"Preload templates","text":"<p>The admin panel has its own templates and static files which need to be preloaded at runtime:</p> <pre><code>use rwf::prelude::*;\nuse rwf::http::{Server, Error};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Error&gt; {\n    // Preload templates and static files.\n    rwf_admin::install()?;\n\n    // Launch the server below.\n}\n</code></pre>"},{"location":"user-guides/admin/#add-routes","title":"Add routes","text":"<p>Add the admin panel routes to your HTTP server:</p> <pre><code>let mut routes = vec![\n    // Your application routes.\n];\n\n// Add admin routes.\nroutes.extend(rwf_admin::routes());\n\n// Launch the server.\nServer::new(routes)\n    .launch()\n    .await?;\n</code></pre>"},{"location":"user-guides/admin/#learn-more","title":"Learn more","text":"<ul> <li>examples/turbo app uses the admin panel</li> <li>rwf-admin</li> </ul>"},{"location":"user-guides/deploy-to-prod/","title":"Deploying to production","text":"<p>Applications written with Rwf are standard Rust apps that can be deployed to production using existing tools, like buildpacks or Docker. Additionally, Rwf comes with its own CLI that can package your application and run it on bare metal hardware without third-party dependencies.</p>"},{"location":"user-guides/deploy-to-prod/#using-the-cli","title":"Using the CLI","text":"<p>The Rwf CLI can package your application with a single command:</p> CommandOutput <pre><code>rwf-cli package\n</code></pre> <pre><code>$ rwf-cli package\nFinished `release` profile [optimized] target(s) in 0.49s\npackaging binary\npackaging static\npackaging templates\npackaging migrations\ncreated build.tar.gz\n</code></pre> <p>This will build your application in release mode and bundle the binary, templates, static files and migrations into a single archive called <code>bundle.tar.gz</code>.</p> <p>Since Rust applications are compiled, they don't require any additional dependencies to run. You can copy the bundle onto your production machine(s), untar it and run the app:</p> <pre><code>tar xvf bundle.tar.gz\n./app\n</code></pre>"},{"location":"user-guides/deploy-to-prod/#cross-compiling","title":"Cross-compiling","text":"<p>If you're developing on one type of hardware, but your production servers run another, you'll need to compile your application for the right CPU architecture.</p> <p>If you have a cross-compiler installed, you can provide the desired architecture as an argument to <code>rwf-cli</code>, for example:</p> <pre><code>rwf-cli package --target aarch64-unknown-linux-gnu\n</code></pre>"},{"location":"user-guides/deploy-to-prod/#using-docker","title":"Using Docker","text":"<p>Docker can bundle the app and its dependencies together, making sure your application can run anywhere Docker is available.</p>"},{"location":"user-guides/deploy-to-prod/#writing-a-dockerfile","title":"Writing a Dockerfile","text":"<p>Writing a Dockerfile for an Rwf application involves compiling the code in release mode and copying over the assets, like static files and templates:</p> <pre><code># Build the app in a separate container.\nFROM rust:1-bullseye AS builder\nCOPY . /build\nWORKDIR /build\nRUN cargo build --release\n\n# Production container using the same\n# Linux distro.\nFROM debian:bullseye\n\n# Copy app from build container.\nCOPY --from=builder /build/target/release/app /app/app\n\n# Copy assets.\nCOPY templates /app/templates\nCOPY static /app/static\nCOPY migrations /app/migrations\n\n# Run the app.\nWORKDIR /app\nCMD [\"app\"]\n</code></pre> <p>Building the application in a separate container makes sure the container running the app in production is small.</p>"},{"location":"user-guides/hot-reload/","title":"Hot reload","text":"<p>Hot reload, also known as hot module replacement (HMR), is a technique for automatically replacing frontend components that changed during local development, without the developer having to reload the page manually. While Rwf templates don't use JavaScript frameworks like React or Vue, they do support being reloaded automatically.</p>"},{"location":"user-guides/hot-reload/#enable-hot-reload","title":"Enable hot reload","text":"<p>To enable template hot reloading, make sure your application is using Turbo Streams. The page refresh event is delivered from the server using a WebSocket connection.</p> <p>Current hot reload implementation works best if you are storing your templates in one directory, e.g. <code>templates</code>. To enable HMR, launch it before launching the HTTP server:</p> <pre><code>use rwf::hmr::hmr;\n\nuse std::path::PathBuf;\n\n#[tokio::main]\nasync fn main() {\n    // Enable HMR notifications for any changes\n    // to the `templates` directory.\n    hmr(PathBuf::from(\"templates\"));\n\n    /* ... */\n}\n</code></pre> <p>When editing templates with your favorite text editor, Rwf will send an event via the Turbo Stream connection which will reload the page every time a template file is saved. Since Turbo makes page reloads seamless, this simulates the behavior of HMR used by frameworks like React or Vue.</p>"},{"location":"user-guides/hot-reload/#debug-only","title":"Debug only","text":"<p>HMR only makes sense in development, so the functionality is available in <code>debug</code> builds which are used by default when you use <code>cargo run</code>. In <code>release</code> builds, HMR is disabled.</p>"},{"location":"user-guides/hot-reload/#learn-more","title":"Learn more","text":"<ul> <li>rwf-admin uses HMR</li> </ul>"},{"location":"user-guides/build-your-app/","title":"Build with Rwf","text":"<p>Rwf has a lot of features and mixing them together can create powerful and efficient web apps. This guide will demonstrate how to build a generic application from scratch using Rwf as your web framework.</p> <p>Note</p> <p>This guide is a work in progress. Please check back soon for more updates. Contributions are welcome!</p>"},{"location":"user-guides/build-your-app/#getting-started","title":"Getting started","text":"<p>If you'd like to build an application with this guide, make sure make sure to install the Rwf CLI first:</p> <pre><code>cargo install rwf-cli\n</code></pre> <p>Once the CLI is installed, make sure to follow the instructions on creating a new Rwf application.</p>"},{"location":"user-guides/build-your-app/#chapters","title":"Chapters","text":"<ol> <li>Add users</li> </ol>"},{"location":"user-guides/build-your-app/add-users/","title":"Add users","text":"<p>Note</p> <p>This guide is a work-in-progress.</p> <p>Unless you're building simple demo applications or static informational websites, your web app will need a way for your users to sign up and personalize their experience. There are many ways to accomplish this, and your implementation should be specific to your use case. For example, many web apps allow users to sign up using an OAuth2 provider like Google or GitHub.</p> <p>In this guide, we'll cover the most popular and simple way to create user accounts: using a username and a password.</p>"},{"location":"user-guides/build-your-app/add-users/#username-and-password","title":"Username and password","text":"<p>Allowing your users to create accounts in your application using a username and password is pretty universal. Implementing this system requires using all 3 components of the MVC framework: creating a database model to store usernames and password hashes, controllers to process sign up and login requests, and views to serve sign up and login forms.</p> <p>Rwf supports all three components natively.</p>"},{"location":"user-guides/build-your-app/add-users/#create-the-model","title":"Create the model","text":"<p>To create a model in Rwf, you need to define the schema in the database and define the model in Rust code. The two should match as closely as possible.</p>"},{"location":"user-guides/build-your-app/add-users/#create-the-schema","title":"Create the schema","text":"<p>Starting with the data model, let's create a simple <code>\"users\"</code> table in your database. This table will store usernames, password hashes, and other metadata about our users, like when their accounts were created.</p> <p>Creating a table with Rwf should be done by writing a migration. This makes sure changes to the database schema are documented and deterministic. To create a migration, use the Rwf CLI:</p> CommandOutput <pre><code>rwf-cli migrate add -n users\n</code></pre> <pre><code>Created \"migrations/1733265254409864495_users.up.sql\"\nCreated \"migrations/1733265254409864495_users.down.sql\"\n</code></pre> <p>The migration is empty, so let's create the table by adding it to the <code>users.up.sql</code> file:</p> <pre><code>CREATE TABLE users (\n    id BIGSERIAL PRIMARY KEY,\n    username VARCHAR NOT NULL UNIQUE,\n    password_hash VARCHAR NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n</code></pre> <p>As mentioned above, our table will store usernames, password hashes, and metadata. The <code>id</code> column is the primary key of this table, allowing us to identify our users using a unique number.</p> <p>Note</p> <p>Rwf models by default expect the presence of the <code>id</code> column, and use it as the primary key. This is configurable on a per-model basis, and models can be created without a primary key, but this will prevent them from being updated or deleted by the ORM.</p> <p>Once the schema is ready, create the table in the database by applying the migration:</p> CommandOutput <pre><code>rwf-cli migrate run\n</code></pre> <pre><code>applying migration \"1733265254409864495_users\"\nmigration \"1733265254409864495_users\" applied\n</code></pre>"},{"location":"user-guides/build-your-app/add-users/#define-the-rust-model","title":"Define the Rust model","text":"<p>With the schema ready to go, we need to create a Rust struct which we'll use in code to reference the model records. The Rust struct should have the same fields as the columns in our table, and their data types should match as well:</p> <pre><code>#[derive(Clone, macros::Model)]\npub struct User {\n    id: Option&lt;i64&gt;,\n    username: String,\n    password_hash: String,\n    created_at: OffsetDateTime,\n}\n</code></pre>"},{"location":"views/","title":"Views basics","text":"<p>Rwf comes with a templating library that can generate dynamic pages. Dynamic templates allow you to create unique HTML pages on the fly, and libraries like Turbo can use it in a way that feels like a native frontend application.</p>"},{"location":"views/#what-are-views","title":"What are views?","text":"<p>Views are the V in MVC: they control what your users see and how they experience your web app. Separating views from controllers allows controllers to reuse similar parts of your web app on different pages without code duplication.</p>"},{"location":"views/#using-javascript-frontends","title":"Using JavaScript frontends","text":"<p>If you prefer to build your frontend with JavaScript libraries like React or Vue, take a look at Rwf's REST API documentation. Rwf templates are not required to build web applications.</p>"},{"location":"views/#learn-more","title":"Learn more","text":"<ul> <li>Templates</li> <li>Turbo</li> </ul>"},{"location":"views/templates/","title":"Templates overview","text":"<p>Dynamic templates are a mix of HTML and a programming language which directs how the HTML is displayed. For example, if you have a profile page for your web app users, you would want each of your users to have a page unique to them. To achieve this, you would write only one template and substitute unique aspects of each using template variables, for example:</p> <pre><code>&lt;div class=\"profile\"&gt;\n  &lt;h2&gt;&lt;%= username %&gt;&lt;/h2&gt;\n  &lt;p&gt;&lt;%= bio %&gt;&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>The variables <code>username</code> and <code>bio</code> can be substituted for values unique to each of your users, for example:</p> RustOutput <pre><code>use rwf::prelude::*;\n\nlet template = Template::from_str(r#\"\n&lt;div class=\"profile\"&gt;\n  &lt;h2&gt;&lt;%= username %&gt;&lt;/h2&gt;\n  &lt;p&gt;&lt;%= bio %&gt;&lt;/p&gt;\n&lt;/div&gt;\n\"#)?;\n\nlet ctx = context!(\n  \"username\" =&gt; \"Alice\",\n  \"bio\" =&gt; \"I like turtles\"\n);\n\nlet html = template.render(&amp;ctx)?;\n\nprintln!(\"{}\", html);\n</code></pre> <pre><code>&lt;div class=\"profile\"&gt;\n  &lt;h2&gt;Alice&lt;/h2&gt;\n  &lt;p&gt;I like turtles&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <p>Templates help reuse HTML (and CSS, JavaScript) just like regular functions and structs help reuse code.</p>"},{"location":"views/templates/#learn-more","title":"Learn more","text":"<ul> <li>Variables</li> <li>For loops</li> <li>If statements</li> </ul>"},{"location":"views/templates/caching/","title":"Template cache","text":"<p>Templates are compiled and evaluated on the fly. This is handy for local development, allowing you to modify the template without recompiling the Rust app or restarting the web server, but in production could be an unnecessary performance hindrance.</p> <p>The template cache makes sure a template is compiled only once. All subsequent executions of the template will use an internal representation and are much faster to run.</p>"},{"location":"views/templates/caching/#using-the-cache","title":"Using the cache","text":"<p>To use the template cache, templates must be stored on disk, for example in a <code>templates</code> directory. Loading a template should use the <code>Template::load</code> function:</p> <pre><code>let template = Template::load(\"templates/index.html\")?;\n</code></pre> <p>The first time the template is loaded, it will be fetched from disk and compiled. Once compiled, it will be stored in the cache to be reused by all subsequent calls to <code>Template::load</code>.</p> <p>Note</p> <p>The <code>render!</code> macro is taking advantage of the template cache as well since it uses the <code>Template::load</code> function.</p>"},{"location":"views/templates/caching/#enable-the-cache","title":"Enable the cache","text":"<p>The template cache is disabled by default in development, and enabled in production<sup>1</sup>. To change this behavior, toggle the <code>cache_templates</code> setting in configuration.</p> <ol> <li> <p>This assumes you build your application using the <code>release</code> profile, e.g. <code>cargo build --release</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"views/templates/context/","title":"Template context","text":"<p>Template context is a collection of variables that are passed to a template during rendering. The variables in the template are replaced with the values in the context, producing the final rendering of the template.</p> <p>Using different contexts for the same template allows for templates to be re-used in different parts of the application, without having to write the same HTML/CSS/JavaScript multiple times.</p>"},{"location":"views/templates/context/#create-a-context","title":"Create a context","text":"<p>A context is a key/value mapping of variable names to variable values. Rwf allows it to be created in many different ways, depending on the situation, but the simplest is to use the <code>context!</code> macro:</p> <pre><code>let ctx = context!(\n    \"title\" =&gt; \"Empire strikes back\",\n    \"r2d2_password\" =&gt; vec![\n        1_i64, 1, 2, 3, 5, 8,\n    ],\n);\n</code></pre> <p>The values passed to the <code>context!</code> macro are automatically converted from Rust into the right template data type.</p>"},{"location":"views/templates/context/#type-safe-context","title":"Type-safe context","text":"<p>If you want to re-use the same context in multiple places or you want to ensure the right types are passed in at creation, you can define a struct and convert it into a context using the <code>macros::Context</code> derive:</p> <pre><code>#[derive(macros::Context)]\nstruct Variables {\n    title: String,\n    r2d2_password: Vec&lt;i64&gt;,\n}\n</code></pre> <p>You can instantiate this context now like a regular struct and pass it to a template, for example:</p> <pre><code>let ctx = Variables {\n    title: \"The last Jedi\".to_string(),\n    r2d2_password: vec![1, 1, 2, 2, 3, 3],\n};\nlet rendered = template.render(&amp;ctx)?;\n</code></pre>"},{"location":"views/templates/context/#learn-more","title":"Learn more","text":"<ul> <li>For loops</li> <li>If statements</li> <li>Templates in controllers</li> </ul>"},{"location":"views/templates/for-loops/","title":"For loops","text":"<p>Rwf templates have only one kind of for loop: for each. This allows writing more reliable templates, and to avoid common bugs like infinite loops, which will stall a web app in production.</p> <p>A for loop can iterate over a list of values, for example:</p> <pre><code>&lt;ul&gt;\n&lt;% for value in list %&gt;\n  &lt;li&gt;&lt;%= value %&gt;&lt;/li&gt;\n&lt;% end %&gt;\n&lt;/ul&gt;\n</code></pre> <p>Template lists, unlike Rust's <code>Vec</code>, can hold variables of different data types, and are dynamically evaluated at runtime:</p> TemplateOutput <pre><code>&lt;% for value in [\"one\", 2 * 5, 3/1.5] %&gt;\n&lt;%= value %&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>one\n10\n2.0\n</code></pre>"},{"location":"views/templates/for-loops/#do-n-times","title":"Do n times","text":"<p>If you need to execute some code multiple times, templates come with a handy <code>times</code> function:</p> TemplateOutput <pre><code>&lt;% for n in 5.times %&gt;\n  &lt;li&gt;&lt;%= n %&gt;.&lt;/li&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>&lt;li&gt;1.&lt;/li&gt;\n&lt;li&gt;2.&lt;/li&gt;\n&lt;li&gt;3.&lt;/li&gt;\n&lt;li&gt;4.&lt;/li&gt;\n&lt;li&gt;5.&lt;/li&gt;\n</code></pre>"},{"location":"views/templates/if-statements/","title":"If statements","text":"<p>If statements allow you to control the flow of templates, conditionally displaying some elements while hiding others. For example, if a variable is \"falsy\", you can hide entire sections of your website:</p> <pre><code>&lt;% if logged_in %&gt;\n  &lt;!-- profile page --&gt;\n&lt;% else %&gt;\n  &lt;!-- login page --&gt;\n&lt;% end %&gt;\n</code></pre> <p>If statements start with <code>if</code> and must always finish with <code>end</code>.</p>"},{"location":"views/templates/if-statements/#expressions","title":"Expressions","text":"<p>If statements support evaluating large expressions for truthiness, for example:</p> <pre><code>&lt;% if var.lower + \"_\" + bar.upper == \"lo_HI\" %&gt;\n  &lt;!-- do something --&gt;\n&lt;% end %&gt;\n</code></pre> <p>While it's advisable to write simple if statements and delegate complex logic to views where the Rust compiler can be more helpful, Rwf template language is almost Turing-complete and can be used to write arbitrarily complex templates.</p>"},{"location":"views/templates/if-statements/#operator-precedence","title":"Operator precedence","text":"<p>Templates respect operator precedence, e.g., multiplication is performed before addition, unless parentheses are specified (which are also supported).</p>"},{"location":"views/templates/if-statements/#else-if","title":"Else If","text":"<p>If statements support else if blocks (written as <code>elsif</code>), evaluating multiple expressions and executing the first one which evaluates to true:</p> <pre><code>&lt;% if one %&gt;\n  &lt;!-- one --&gt;\n&lt;% elsif two %&gt;\n  &lt;!-- two --&gt;\n&lt;% elsif three %&gt;\n  &lt;!-- three --&gt;\n&lt;% else %&gt;\n  &lt;!-- I guess it's four? ---&gt;\n&lt;% end %&gt;\n</code></pre>"},{"location":"views/templates/nomenclature/","title":"Nomenclature","text":""},{"location":"views/templates/nomenclature/#expressions","title":"Expressions","text":"<p>Expressions are a combination of terms and operators which evaluate to a single value, for example:</p> TemplateOutput <pre><code>&lt;%= 5 * 2 / 10 %&gt;\n</code></pre> <pre><code>1\n</code></pre>"},{"location":"views/templates/nomenclature/#statements","title":"Statements","text":"<p>Statements are commands given to the template language interpreter to do something, e.g. output the value of an expression, or execute a for loop.</p>"},{"location":"views/templates/partials/","title":"Partials","text":"<p>Partials are templates that can be rendered inside other templates to facilitate reuse of frontend code. For example, if you have a navigation menu in your app, you would want it to look the same on all pages, but you don't want to implement the same menu many times. To achieve this, you can write a partial and insert it in all templates where it's needed.</p>"},{"location":"views/templates/partials/#writing-partials","title":"Writing partials","text":"<p>A partial is just another template. It has to be stored on disk, in a directory reachable from your application, for example <code>templates/partials</code>.</p> <p>Using the navigation menu as an example, we can define a partial in <code>templates/partials/nav.html</code>, as follows:</p> <pre><code>&lt;nav&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"/profile\"&gt;Profile&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/nav&gt;\n</code></pre> <p>Rendering partials can be done in any template, using the special <code>&lt;%%</code> tag, for example:</p> TemplateOutput <pre><code>&lt;html&gt;\n  &lt;head&gt;\n  &lt;!-- ... --&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;%% \"templates/partials/nav.html\" %&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n  &lt;!-- ... --&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;nav&gt;\n      &lt;ul&gt;\n        &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href=\"/profile\"&gt;Profile&lt;/a&gt;&lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/nav&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"views/templates/partials/#using-variables","title":"Using variables","text":"<p>Partials can use variables like a regular template. When rendered, they inherit the variables and scope of the template they are used in, for example:</p> PartialTemplate <pre><code>&lt;h1&gt;&lt;%= user.name %&gt;&lt;/h1&gt;\n&lt;p&gt;&lt;%= user.bio %&gt;&lt;/p&gt;\n</code></pre> <pre><code>&lt;% for user in users %&gt;\n  &lt;%% \"templates/partials/user.html\" %&gt;\n&lt;% end %&gt;\n</code></pre>"},{"location":"views/templates/templates-in-controllers/","title":"Templates in controllers","text":"<p>Using templates in controllers typically involves rendering them inside a request handler and returning the result as HTML, for example:</p> <pre><code>struct Index;\n\n#[async_trait]\nimpl Controller for Index {\n    async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        let template = Template::load(\"templates/index.html\")?;\n        let ctx = context!(\"title\" =&gt; \"Home page\");\n        let rendered = template.render(&amp;ctx)?;\n\n        Ok(Response::new().html(rendered))\n    }\n}\n</code></pre> <p>The template will be loaded from the template cache, rendered with the provided context, and used as a body for a response with the correct <code>Content-Type</code> header.</p>"},{"location":"views/templates/templates-in-controllers/#render-macro","title":"Render macro","text":"<p>Since it's very common to render templates inside controllers, Rwf has the <code>render!</code> macro to make it less verbose:</p> <pre><code>#[async_trait]\nimpl Controller for Index {\n    async fn handle(&amp;self, request: &amp;Request) -&gt; Result&lt;Response, Error&gt; {\n        render!(request, \"templates/index.html\", \"title\" =&gt; \"Home page\")\n    }\n}\n</code></pre> <p>The <code>render!</code> macro takes the request as the first argument, the template path, and optionally a mapping of variable names and values. It returns a <code>Response</code> automatically.</p> <p>If the template doesn't have any variables, you can omit them:</p> <pre><code>render!(request, \"templates/index.html\")\n</code></pre> <p>Passing the request into the macro ensures that secure CSRF protection tokens are generated automatically.</p>"},{"location":"views/templates/templates-in-controllers/#response-code","title":"Response code","text":"<p>By default, the <code>render!</code> macro returns the rendered template with HTTP code <code>200 OK</code>. If you want to return a different code, pass it as the last argument to the macro:</p> <pre><code>render!(request, \"templates/index.html\", \"title\" =&gt; \"Home page\", 201)\n</code></pre>"},{"location":"views/templates/variables/","title":"Variables","text":"<p>Template variables are used to substitute unique information into a reusable template. Rwf supports variables of different kinds, like strings, numbers, lists, and hashes. Complex variables like hashes and lists can be iterated through using for loops.</p>"},{"location":"views/templates/variables/#using-variables","title":"Using variables","text":"<p>Using variables in your templates is typically done by \"printing\" them, or outputting them, into the template text. This is achieved by placing them between <code>&lt;%=</code> and <code>%&gt;</code> tags, for example:</p> <pre><code>&lt;%= variable %&gt;\n</code></pre> <p>The <code>&lt;%=</code> tag indicates what follows is an expression, which should be evaluated and converted to text for displaying purposes.</p> <p>The <code>%&gt;</code> tag is not specific to printing variables, and indicates the end of a template expression or statement.</p>"},{"location":"views/templates/variables/#defining-variables","title":"Defining variables","text":"<p>A variable is defined when a template is rendered. Using one of many possible ways to define a context, the variable is given a value at runtime:</p> RustOutput <pre><code>let ctx = context!(\"variable\" =&gt; \"I love pancakes for dinner.\");\n\nlet template = Template::from_str(\"&lt;%= variable %&gt;\")?;\nlet string = template.render(&amp;ctx)?;\n\nprintln!(\"{}\", string);\n</code></pre> <pre><code>I love pancakes for dinner.\n</code></pre>"},{"location":"views/templates/variables/#missing-variables","title":"Missing variables","text":"<p>It's not uncommon to forget to define variables, especially if a template is large, or used in multiple places in the app where some variables don't have a known value.</p> <p>If an undefined variable is used in a template, Rwf will throw a runtime error. This is good for debugging issues when variables are unintentionally forgotten by the developer. However, if the variable is not always available, you can check if it's defined first:</p> <pre><code>&lt;% if variable %&gt;\n  &lt;p&gt;&lt;%= variable %&gt;&lt;/p&gt;\n&lt;% end %&gt;\n</code></pre> <p>Due to the nature of if statements, if the variable is defined and evaluates to a \"falsy\" value, e.g. <code>0</code>, <code>\"\"</code> (empty string), <code>null</code>, etc., the if statement will not be executed either. This is helpful for handling many similar cases without having to write complex statements.</p>"},{"location":"views/templates/variables/#default-values","title":"Default values","text":"<p>It's possible to define default values for variables that are <code>null</code> or haven't been set in the template context:</p> <pre><code>&lt;p&gt;&lt;%= default(variable, \"Some default text\") %&gt;&lt;/p&gt;\n</code></pre> <p>Note</p> <p>While it's tempting to have defaults for most variables to avoid runtime errors, it's often best to throw an error that you can catch in testing instead. Default values are not always optimal for best user experience.</p>"},{"location":"views/templates/variables/#global-defaults","title":"Global defaults","text":"<p>If a variable is used in multiple templates but its value is typically the same, you can define it globally for all templates. This ensures that if used in a template where it's not defined, the default value is printed instead of throwing an error.</p> <p>Global variables can be defined on application startup:</p> <pre><code>#[tokio::main]\nasync fn main() {\n    Template::defaults(context!(\n        \"global_var\" =&gt; \"Some value\",\n        \"global_var_2\" =&gt; 25,\n    ));\n}\n</code></pre> <p>Note</p> <p>While it's possible to define global variables multiple times anywhere in the code, only the last declaration will be used.</p> <p>You can override default variables in each template, by specifying the variable value when rendering the template:</p> <pre><code>render!(request, \"templates/index.html\", \"global_var\" =&gt; \"Another value\")\n</code></pre>"},{"location":"views/templates/variables/#supported-data-types","title":"Supported data types","text":"<p>Rwf variables support most Rust data types. The conversion between Rust and the template language happens automatically.</p>"},{"location":"views/templates/variables/#number","title":"Number","text":"<p>Rwf supports two kinds of numbers: integers and floating points.</p> <p>An integer is any whole number, negative or positive (including zero). Rust has many integer types, e.g. <code>i8</code>, <code>i32</code>, <code>u64</code>, etc., but the template language converts all of them to an 64-bit singed integer:</p> TemplateOutput <pre><code>&lt;%= 500 %&gt;\n</code></pre> <pre><code>500\n</code></pre> <p>Rust's <code>f32</code> and <code>f64</code> are converted to 64-bit double precision floating point. Operations between integers and floating points are supported, the final result being a float:</p> TemplateOutput <pre><code>&lt;%= 500 + 1.5 %&gt;\n</code></pre> <pre><code>501.5\n</code></pre> <p>Numbers can be converted to strings, floored, ceiled and rounded, for example:</p> TemplateOutput <pre><code>&lt;%= 123.45.round.to_s %&gt;\n</code></pre> <pre><code>123\n</code></pre>"},{"location":"views/templates/variables/#strings","title":"Strings","text":"<p>Strings in templates can be used in two ways:</p> <ul> <li><code>&lt;%=</code> (print) operator, which outputs the string, escaping any dangerous HTML characters, e.g. <code>&lt;</code> becomes <code>&amp;lt;</code></li> <li><code>&lt;%-</code> operator which performs no conversions and prints the string as-is</li> </ul> TemplateOutput <pre><code>&lt;%= \"&lt;script&gt;\" %&gt;\n&lt;%- \"&lt;script&gt;\" %&gt;\n</code></pre> <pre><code>&amp;lt;script&amp;gt;\n&lt;script&gt;\n</code></pre> <p>Note</p> <p>If you're coming here from Rails, the <code>&lt;%-</code> operator works differently.  In ERB, the <code>&lt;%-</code> operator prints the string without trailing or leading spaces. The equivalent in Rwf would be to call <code>trim</code>, for example:</p> <pre><code>&lt;%= variable.trim %&gt;\n</code></pre>"},{"location":"views/templates/variables/#string-security","title":"String security","text":"<p>Escaping HTML characters is a good idea in case your users are the ones supplying the value of the string. This prevents script injection attacks, e.g. users placing malicious code on your website.</p> <p>Unless you're sure about the provenance of a string, use <code>&lt;%=</code> to output it in templates.</p>"},{"location":"views/templates/variables/#boolean","title":"Boolean","text":"<p>Boolean variables can either be <code>true</code> or <code>false</code>. They map directly to Rust's <code>bool</code> data type.</p>"},{"location":"views/templates/variables/#lists","title":"Lists","text":"<p>Lists are arrays of other template variables, including other lists, strings, numbers, and hashes. In templates, lists can be defined by using square brackets, and iterated on using for loops, for example:</p> TemplateOutput <pre><code>&lt;% for item in [1, 2, \"three\"] %&gt;\n&lt;%= item %&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>1\n2\nthree\n</code></pre> <p>Rwf lists are flexible and can contain multiple data types. This separates them from Rust's <code>Vec</code> and slices which can only hold one kind of data.</p> <p>You can also access a specific element in a list by indexing into it with the dot(<code>.</code>) notation:</p> <pre><code>&lt;%= list.1 %&gt;\n</code></pre> <p>Lists are 0-indexed, so the above example accesses the second element in the list.</p>"},{"location":"views/templates/variables/#hashes","title":"Hashes","text":"<p>Hashes, also known as dicts or hash tables, are a key/value storage data type. Unlike a list, it contains a mapping between a value (the key), and a value. Values can be accessed by knowing a key, or by iterating through the entire hash with a for loop:</p> <pre><code>&lt;p&gt;&lt;%= user.name %&gt;&lt;/p&gt;\n&lt;p&gt;&lt;%= user.email %&gt;&lt;/p&gt;\n</code></pre> <p>Rwf hashes use the dot (<code>.</code>) notation to access values in a hash. In this example, the <code>user</code> is a hash, and <code>name</code> and <code>email</code> are keys.</p>"},{"location":"views/templates/variables/#truthy-vs-falsy","title":"Truthy vs. falsy","text":"<p>Variables are often used in if statements to decide whether to execute some code or not. To make the template language less verbose, variables can be evaluated for truthiness without calling explicit functions depending on their data type.</p> <p>The following variables and data types evaluate to false:</p> Data type Value Integer <code>0</code> Float <code>0.0</code> Boolean <code>false</code> String <code>\"\"</code> (empty) List <code>[]</code> (empty) Hash <code>{}</code> (empty) <p>All other variables evaluate to true.</p>"},{"location":"views/templates/variables/#learn-more","title":"Learn more","text":"<ul> <li>Context</li> <li>If statements</li> <li>For loops</li> <li>Functions</li> </ul>"},{"location":"views/templates/functions/","title":"Functions overview","text":"<p>Templates provide a number of functions that manipulate constants and variables. Each data type has its own set of functions, which you can call using the dot (<code>.</code>) notation, for example:</p> TemplateOutput <pre><code>&lt;%= \"lowercase\".upper %&gt;\n</code></pre> <pre><code>LOWERCASE\n</code></pre>"},{"location":"views/templates/functions/#functions","title":"Functions","text":"<ul> <li>String functions</li> <li>Integer functions</li> <li>Float functions</li> <li>Hash functions</li> <li>List functions</li> </ul>"},{"location":"views/templates/functions/#general-helpers","title":"General helpers","text":"<p>These functions can be called on any value, irrespective of data type.</p>"},{"location":"views/templates/functions/#null","title":"<code>null</code>","text":"<p>Returns true if the value is null, false if not.</p> <pre><code>&lt;h1&gt;\n  &lt;% if title.null %&gt;\n    Unnamed\n  &lt;% else %&gt;\n    &lt;%= title %&gt;\n  &lt;% end %&gt;\n&lt;/h1&gt;\n</code></pre> <p>Aliases:</p> <ul> <li><code>nil</code></li> <li><code>blank</code></li> </ul>"},{"location":"views/templates/functions/#numeric","title":"<code>numeric</code>","text":"<p>Returns true if the value is a number, i.e. integer or float. Return false if not.</p> <pre><code>&lt;% if value.numeric %&gt;\n  &lt;input type=\"number\"&gt;\n&lt;% else %&gt;\n  &lt;input type=\"text\"&gt;\n&lt;% end %&gt;\n</code></pre>"},{"location":"views/templates/functions/#integer","title":"<code>integer</code>","text":"<p>Returns true if the value is an integer, false otherwise.</p> <pre><code>&lt;% 5.integer == true %&gt;\n</code></pre>"},{"location":"views/templates/functions/#float","title":"<code>float</code>","text":"<p>Returns true if the value is an integer, false otherwise.</p> <pre><code>&lt;% 5.float == false %&gt;\n</code></pre>"},{"location":"views/templates/functions/#default","title":"<code>default</code>","text":"<p>Checks that a variable is defined and returns it. If the variable is not defined, returns the provided default value instead.</p> TemplateOutput <pre><code>&lt;%= default(some_var, \"default_value\") %&gt;\n</code></pre> <p>If <code>some_var</code> variable is not defined: <pre><code>default_value\n</code></pre> If <code>some_var</code> is set to <code>\"value\"</code>: <pre><code>value\n</code></pre></p>"},{"location":"views/templates/functions/#global-helpers","title":"Global helpers","text":"<p>Global functions are standalone and are not called on a value. They are used to generate some useful code in the template.</p>"},{"location":"views/templates/functions/#rwf_head","title":"<code>rwf_head</code>","text":"<p>Inserts JavaScript into template that makes Rwf work smoothly. Currently this function downloads and initializes Hotwired Turbo and Stimulus libraries. As the name of the function suggests, it's best used inside the <code>&lt;head&gt;</code> element, for example:</p> <pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;%- rwf_head() %&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- ... --&gt;\n</code></pre>"},{"location":"views/templates/functions/#rwf_turbo_stream","title":"<code>rwf_turbo_stream</code>","text":"<p>Inserts JavaScript code which will create and initialize a Turbo Stream WebSocket connection. Use this function inside the <code>&lt;body&gt;</code> element<sup>1</sup>:</p> <pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;%- rwf_head() %&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;%- rwf_turbo_stream(\"/turbo-stream\") %&gt;\n    &lt;!-- ... --&gt;\n</code></pre>"},{"location":"views/templates/functions/#render","title":"<code>render</code>","text":"<p>Renders a template directly inside the current template. Can be used for rendering partials. <code>&lt;%%</code> is a special template code tag which is an alias for <code>render</code>.</p> <pre><code>&lt;div&gt;\n  &lt;%- render(\"templates/profile.html\") %&gt;\n&lt;/div&gt;\n\n&lt;!-- The same as: --&gt;\n\n&lt;div&gt;\n  &lt;%% \"templates/profile.html\" %&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"views/templates/functions/#csrf_token","title":"<code>csrf_token</code>","text":"<p>Renders an input field with a valid CSRF token.</p> <pre><code>&lt;form action=\"/login\" method=\"post\"&gt;\n    &lt;%= csrf_token() %&gt;\n&lt;/form&gt;\n</code></pre>"},{"location":"views/templates/functions/#csrf_token_raw","title":"<code>csrf_token_raw</code>","text":"<p>Renders a valid CSRF token as a raw HTML string. It can then be passed to JavaScript via a <code>data-</code> attribute or a global variable:</p> <pre><code>&lt;div data-csrf-token=\"&lt;%= csrf_token_raw() %&gt;\"\n&lt;/div&gt;\n</code></pre> <ol> <li> <p>https://turbo.hotwired.dev/handbook/streams \u21a9</p> </li> </ol>"},{"location":"views/templates/functions/float/","title":"Float functions","text":""},{"location":"views/templates/functions/float/#abs","title":"<code>abs</code>","text":"<p>Returns the absolute (non-negative) value of the floating point.</p> TemplateOutput <pre><code>&lt;%= -5.0.abs %&gt;\n</code></pre> <pre><code>5.0\n</code></pre>"},{"location":"views/templates/functions/float/#to_string","title":"<code>to_string</code>","text":"<p>Converts the floating point to a string. <code>to_s</code> is an alias for <code>to_string</code>.</p> TemplateOutput <pre><code>&lt;%= 5.2.to_string + \" times\" %&gt;\n</code></pre> <pre><code>5.2 times\n</code></pre>"},{"location":"views/templates/functions/float/#to_integer","title":"<code>to_integer</code>","text":"<p>Converts the floating point to an integer, rounding it. <code>to_i</code> is an alias for <code>to_integer</code>.</p> TemplateOutput <pre><code>&lt;%= 5.2.to_integer * 5 %&gt;\n</code></pre> <pre><code>25\n</code></pre>"},{"location":"views/templates/functions/float/#round","title":"<code>round</code>","text":"<p>Rounds the floating point to the nearest whole value.</p> TemplateOutput <pre><code>&lt;%= 5.6.round %&gt;\n</code></pre> <pre><code>6.0\n</code></pre>"},{"location":"views/templates/functions/float/#ceil","title":"<code>ceil</code>","text":"<p>Rounds the float to the upper whole value.</p> TemplateOutput <pre><code>&lt;%= 5.2.ceil %&gt;\n</code></pre> <pre><code>6.0\n</code></pre>"},{"location":"views/templates/functions/float/#floor","title":"<code>floor</code>","text":"<p>Rounds the float to the lower whole value.</p> TemplateOutput <pre><code>&lt;%= 5.9.ceil %&gt;\n</code></pre> <pre><code>5.0\n</code></pre>"},{"location":"views/templates/functions/hash/","title":"Hash functions","text":""},{"location":"views/templates/functions/hash/#keys","title":"<code>keys</code>","text":"<p>Converts the hash to a list of keys stored in the hash.</p> TemplateContextOutput <pre><code>&lt;% for fruit in fruits.keys %&gt;\n    &lt;%= fruit %&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>context!(\n    \"fruits\" =&gt; HashMap::from([\n        (\"apples\", \"red\"),\n        (\"bananas\", \"yellow\")\n    ])\n);\n</code></pre> <pre><code>apples\nbananas\n</code></pre>"},{"location":"views/templates/functions/hash/#values","title":"<code>values</code>","text":"<p>Converts the hash to a list of values stored in the hash.</p> TemplateContextOutput <pre><code>&lt;% for color in fruits.values %&gt;\n    &lt;%= color %&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>context!(\n    \"fruits\" =&gt; HashMap::from([\n        (\"apples\", \"red\"),\n        (\"bananas\", \"yellow\")\n    ])\n);\n</code></pre> <pre><code>red\nyellow\n</code></pre>"},{"location":"views/templates/functions/hash/#iter","title":"<code>iter</code>","text":"<p>Converts the hash to a list of key &amp; value tuples that are stored in the hash. When used inside a for loop, calling <code>iter</code> is optional.</p> TemplateContextOutput <pre><code>&lt;% for tuple in fruits %&gt;\n    &lt;%= tuple.0 %&gt; are &lt;%= tuple.1 %&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>context!(\n    \"fruits\" =&gt; HashMap::from([\n        (\"apples\", \"red\"),\n        (\"bananas\", \"yellow\")\n    ])\n);\n</code></pre> <pre><code>apples are red\nbananas are yellow\n</code></pre>"},{"location":"views/templates/functions/hash/#empty","title":"<code>empty</code>","text":"<p>Returns true if the hash is empty (length 0). <code>blank</code> and <code>is_empty</code> are aliases for <code>empty</code>.</p> TemplateContextOutput <pre><code>&lt;%= fruits.empty %&gt;\n</code></pre> <pre><code>context!(\n    \"fruits\" =&gt; HashMap::new(),\n);\n</code></pre> <pre><code>true\n</code></pre>"},{"location":"views/templates/functions/hash/#len","title":"<code>len</code>","text":"<p>Returns the length of the hash, i.e. the number of elements stored in the hash.</p> TemplateContextOutput <pre><code>&lt;%= fruits.len %&gt;\n</code></pre> <pre><code>context!(\n    \"fruits\" =&gt; HashMap::new(),\n);\n</code></pre> <pre><code>0\n</code></pre>"},{"location":"views/templates/functions/integer/","title":"Integer functions","text":""},{"location":"views/templates/functions/integer/#abs","title":"<code>abs</code>","text":"<p>Returns the absolute (non-negative) value of the integer.</p> TemplateOutput <pre><code>&lt;%= -5.abs %&gt;\n</code></pre> <pre><code>5\n</code></pre>"},{"location":"views/templates/functions/integer/#to_string","title":"<code>to_string</code>","text":"<p>Converts the integer to a string. <code>to_s</code> is an alias for <code>to_string</code>.</p> TemplateOutput <pre><code>&lt;%= 5.to_string + \" times\" %&gt;\n</code></pre> <pre><code>5 times\n</code></pre>"},{"location":"views/templates/functions/integer/#to_float","title":"<code>to_float</code>","text":"<p>Converts the integer to a floating point number. <code>to_f</code> is an alias for <code>to_float</code>.</p> TemplateOutput <pre><code>&lt;%= 5.to_float * 2.5 %&gt;\n</code></pre> <pre><code>12.5\n</code></pre>"},{"location":"views/templates/functions/integer/#times","title":"<code>times</code>","text":"<p>Creates a list of integers, starting at 0 and ending with the integer. This function is commonly used to run a for loop, for example:</p> TemplateOutput <pre><code>&lt;% for i in 3.times %&gt;\n    &lt;%= i %&gt;.\n&lt;% end %&gt;\n</code></pre> <pre><code>1.\n2.\n3.\n</code></pre>"},{"location":"views/templates/functions/integer/#clamp_zero","title":"<code>clamp_zero</code>","text":"<p>Clamps the integer to 0, i.e. negative values become 0.</p> TemplateOutput <pre><code>&lt;%= -25.clamp_zero %&gt;\n</code></pre> <pre><code>0\n</code></pre>"},{"location":"views/templates/functions/integer/#clamp_one","title":"<code>clamp_one</code>","text":"<p>Clamps the integer to 1, i.e. all values less than 1 become 1.</p> TemplateOutput <pre><code>&lt;%= 0.clamp_one %&gt;\n</code></pre> <pre><code>1\n</code></pre>"},{"location":"views/templates/functions/integer/#replace","title":"<code>replace</code>","text":"<p>Replaces matching integer(s) in the number. <code>sub</code> is an alias for <code>replace</code>.</p> TemplateOutput <pre><code>&lt;%= 15345.replace(5, 6) %&gt;\n</code></pre> <pre><code>16346\n</code></pre>"},{"location":"views/templates/functions/list/","title":"List functions","text":""},{"location":"views/templates/functions/list/#enumerate","title":"<code>enumerate</code>","text":"<p>Converts the list to a new list of tuples. Each tuple contains the element's position in the original list and its value.</p> TemplateOutput <pre><code>&lt;% for tuple in [1, 2, 3].enumerate %&gt;\n    &lt;%= tuple.0 %&gt;. &lt;%= tuple.1 %&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>0. 1\n1. 2\n2. 3\n</code></pre>"},{"location":"views/templates/functions/list/#reverse","title":"<code>reverse</code>","text":"<p>Reverses the order of elements in the list. <code>rev</code> is an alias for <code>reverse</code>.</p> TemplateOutput <pre><code>&lt;% for value in [1, 2, 3].reverse %&gt;\n    &lt;%= value %&gt;\n&lt;% end %&gt;\n</code></pre> <pre><code>3\n2\n1\n</code></pre>"},{"location":"views/templates/functions/list/#len","title":"<code>len</code>","text":"<p>Returns the length of the list.</p> TemplateOutput <pre><code>&lt;%= [1, 2, 3].len %&gt;\n</code></pre> <pre><code>3\n</code></pre>"},{"location":"views/templates/functions/list/#empty","title":"<code>empty</code>","text":"<p>Returns true if the list is empty (length 0).</p> TemplateOutput <pre><code>&lt;%= [1, 2, 3].empty %&gt;\n</code></pre> <pre><code>false\n</code></pre>"},{"location":"views/templates/functions/string/","title":"String functions","text":""},{"location":"views/templates/functions/string/#to_uppercase","title":"<code>to_uppercase</code>","text":"<p>Converts the string to uppercase lettering. <code>upper</code> is an alias for <code>to_uppercase</code>.</p> TemplateOutput <pre><code>&lt;%= \"name\".to_uppercase %&gt;\n</code></pre> <pre><code>NAME\n</code></pre>"},{"location":"views/templates/functions/string/#to_lowercase","title":"<code>to_lowercase</code>","text":"<p>Converts the string to lowercase lettering. <code>lower</code> is an alias for <code>to_lowercase</code>.</p> TemplateOutput <pre><code>&lt;%= \"NAME\".to_lowercase %&gt;\n</code></pre> <pre><code>name\n</code></pre>"},{"location":"views/templates/functions/string/#trim","title":"<code>trim</code>","text":"<p>Removes leading and trailing spaces and new line characters from the string.</p> TemplateOutput <pre><code>&lt;%= \" value \".trim + \" ,name \".trim %&gt;\n</code></pre> <pre><code>value,name\n</code></pre>"},{"location":"views/templates/functions/string/#capitalize","title":"<code>capitalize</code>","text":"<p>Capitalizes the first letter of the string.</p> TemplateOutput <pre><code>&lt;%= \"john\".capitalize %&gt;\n</code></pre> <pre><code>John\n</code></pre>"},{"location":"views/templates/functions/string/#underscore","title":"<code>underscore</code>","text":"<p>Converts the string to \"snake_case\" formatting. <code>to_snake_case</code> is an alias for <code>underscore</code>.</p> TemplateOutput <pre><code>&lt;%= \"ClassName\".underscore %&gt;\n</code></pre> <pre><code>class_name\n</code></pre>"},{"location":"views/templates/functions/string/#camelize","title":"<code>camelize</code>","text":"<p>Converts the string to \"CamelCase\" formatting.</p> TemplateOutput <pre><code>&lt;%= \"class_name\".camelize %&gt;\n</code></pre> <pre><code>ClassName\n</code></pre>"},{"location":"views/templates/functions/string/#empty","title":"<code>empty</code>","text":"<p>Returns true if the string is empty (length 0). <code>blank</code> and <code>is_empty</code> are aliases for <code>empty</code>.</p> TemplateOutput <pre><code>&lt;%= \"\".empty %&gt;\n</code></pre> <pre><code>true\n</code></pre>"},{"location":"views/templates/functions/string/#len","title":"<code>len</code>","text":"<p>Returns the length of the string.</p> TemplateOutput <pre><code>&lt;%= \"hello\".len %&gt;\n</code></pre> <pre><code>5\n</code></pre>"},{"location":"views/templates/functions/string/#urldecode","title":"<code>urldecode</code>","text":"<p>Replaces percent-encoding in the string with its ASCII character equivalents. Commonly used to send characters with special meaning inside URLs.</p> TemplateOutput <pre><code>&lt;%= \"hello%3Dworld\".urldecode %&gt;\n</code></pre> <pre><code>hello=world\n</code></pre>"},{"location":"views/templates/functions/string/#urlencode","title":"<code>urlencode</code>","text":"<p>Opposite of <code>urldecode</code>. Replaces ASCII characters with special meaning in URLs with percent-encoded strings.</p> TemplateOutput <pre><code>&lt;%= \"hello=world\".urlencode %&gt;\n</code></pre> <pre><code>hello%3Dworld\n</code></pre>"},{"location":"views/templates/functions/string/#br","title":"<code>br</code>","text":"<p>Replaces new line characters in the string with <code>&lt;br&gt;</code>. Also escapes all HTML tags.</p> TemplateContextOutput <pre><code>&lt;p&gt;&lt;%= message %&gt;&lt;/p&gt;\n</code></pre> <pre><code>context!(\"message\" =&gt; \"Hello Alice\\n\\n, how are you?\")\n</code></pre> <pre><code>&lt;p&gt;Hello Alice&lt;br&gt;&lt;br&gt;, how are you?&lt;/p&gt;\n</code></pre>"},{"location":"views/templates/functions/string/#replace","title":"<code>replace</code>","text":"<p>Replaces a value inside the string with another value. <code>sub</code> is an alias for <code>replace</code>.</p> TemplateOutput <pre><code>&lt;p&gt;&lt;%= \"Apples are tasty\".replace(\"Apples\", \"Oranges\") %&gt;&lt;/p&gt;\n</code></pre> <pre><code>&lt;p&gt;Oranges are tasty&lt;/p&gt;\n</code></pre> <p>This method accepts all data types, but it does convert them to their string representation before performing the replacement. For example, a string can be replaced with an integer:</p> TemplateOutput <pre><code>&lt;%= \"One two three\".replace(\"One\", 1) %&gt;\n</code></pre> <pre><code>1 two three\n</code></pre>"},{"location":"views/templates/functions/string/#title","title":"<code>title</code>","text":"<p>Converts the string to \"Title Case\" formatting.</p> TemplateOutput <pre><code>&lt;%= \"hello world\".title %&gt;\n</code></pre> <pre><code>Hello World\n</code></pre>"},{"location":"views/turbo/","title":"Turbo basics","text":"<p>Hotwired Turbo is a JavaScript library that can intercept HTTP requests to your backend and perform  updates to the frontend without reloading the browser page. The backend produces HTML, generated with dynamic templates, and Turbo updates only the sections of the page that changed. This simulates the behavior of Single-page applications (like the ones written with React or Vue) without using JavaScript on the frontend.</p>"},{"location":"views/turbo/#enabling-turbo","title":"Enabling Turbo","text":"<p>If you're building pages using Rwf's dynamic templates, you can enable Turbo by adding a declaration into the <code>&lt;head&gt;</code> element of your pages:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    &lt;%= rwf_head %&gt;\n  &lt;/head&gt;\n  &lt;!-- ... --&gt;\n</code></pre> <p>Otherwise, you can always get Turbo from a CDN, like Skypack.</p>"},{"location":"views/turbo/#using-turbo","title":"Using Turbo","text":"<p>Once Turbo is loaded, all links and forms will use Turbo automatically. When visiting links or submitting forms, Turbo will intercept the request, send it on the browser's behalf, process the response and replace the contents of the page seamlessly.</p>"},{"location":"views/turbo/#learn-more","title":"Learn more","text":"<ul> <li>Turbo Streams</li> </ul>"},{"location":"views/turbo/building-pages/","title":"Building pages","text":"<p>Turbo can be used to update parts of the page, without having to render the entire page on every request. This is useful when you want to update sections of the page from any endpoint, without having to load several partials or performing redirects.</p> <p>Partial updates uses Turbo Streams, a feature of Turbo that sends page updates via forms or WebSockets.</p>"},{"location":"views/turbo/streams/","title":"Turbo Streams","text":"<p>Turbo can process page changes received via a WebSocket connection. This enables the server to dynamically update the client's page without the client clicking links or submitting forms. Rwf supports this out of the box.</p>"},{"location":"views/turbo/streams/#websocket-endpoint","title":"WebSocket endpoint","text":"<p>Since Turbo Streams use WebSockets to push changes to the client, you need to create a WebSocket endpoint first. Rwf comes with a controller to do just that without any additional configuration:</p> <pre><code>use rwf::prelude::*;\nuse rwf::http::Server;\nuse rwf::controllers::TurboStream;\n\n#[tokio::main]\nasync fn main() {\n    Server::new(vec![\n        route!(\"/turbo-stream\" =&gt; TurboStream),\n    ])\n    .launch()\n    .await\n    .unwrap()\n}\n</code></pre>"},{"location":"views/turbo/streams/#connect-the-app","title":"Connect the app","text":"<p>Turbo has a special HTML element which automatically handles WebSocket connections, called <code>&lt;turbo-stream-source&gt;</code>. This element needs to specify the WebSocket endpoint and be placed in the body of all pages that wish to support Turbo Streams, for example:</p> <pre><code>&lt;html&gt;\n    &lt;body&gt;\n        &lt;turbo-stream-source\n            src=\"ws://localhost:8000/turbo-stream\"&gt;\n        &lt;/turbo-stream-source&gt;\n    &lt;!-- ... --&gt;\n</code></pre> <p>WebSocket connections need to specify the absolute URL for the WebSocket server. The endpoint above uses the development server you're running on localhost, but in production this will be different. To make this easier, Rwf comes with a handy template function which figures out which endpoint to use based on your website's URL:</p> <pre><code>&lt;html&gt;\n    &lt;body&gt;\n        &lt;%= rwf_turbo_stream(\"/turbo-stream\") %&gt;\n    &lt;!-- ... --&gt;\n</code></pre> <p>If your website is running on <code>https://example.com</code>, this function will create a Turbo Stream connection pointing to <code>wss://example.com/turbo-stream</code>.</p> <p>Note</p> <p>The <code>&lt;turbo-stream-source&gt;</code> element must be placed inside the <code>&lt;body&gt;</code>. When visiting pages, Turbo updates the <code>&lt;body&gt;</code> element only, while keeping other elements like <code>&lt;head&gt;</code> intact. To make sure Turbo reconnects to your stream endpoint when loading a page, the stream element needs to be recreated on each page visit.</p>"},{"location":"views/turbo/streams/#send-updates","title":"Send updates","text":"<p>Updates to pages can be sent from anywhere in the code. The only thing you need is the session identifier. If you're sending an update from a controller, you can obtain the session ID from the request:</p> <pre><code>let session_id = request.session_id();\n</code></pre> <p>Once you have the ID, you can send an update directly to that user:</p> <pre><code>// Create the update.\nlet update = TurboStream::new(r#\"\n    &lt;div id=\"messages\"&gt;\n        &lt;p&gt;Hi Alice!&lt;/p&gt;\n        &lt;p&gt;Hello Bob!&lt;/p&gt;\n    &lt;/div&gt;\n\"#).action(\"replace\").target(\"messages\");\n\n// Send it via a WebSocket connection.\nComms::websocket(&amp;session_id).send(update)?;\n</code></pre> <p>If you need to send updates to the client from somewhere else besides a controller, e.g. from a background job, pass the session identifier to that code as an argument. The session identifier is unique and unlikely to change.</p>"},{"location":"views/turbo/streams/#using-templates","title":"Using templates","text":"<p>It's common for Turbo Streams to update elements on a page for which templates already exist. To easily render a template or partial and wrap it into a Turbo Stream, Rwf has a handy macro:</p> <pre><code>let stream = turbo_stream!(\n    \"templates/partials/messages.html\", // Template name.\n    \"messages\", // DOM element ID.\n    \"messages\" =&gt; vec![\"Hi Alice\", \"Hi Bob\"], // Template variables.\n)\n</code></pre> <p>The Turbo Stream can be returned as a response to a form submission, or sent via the Turbo Stream WebSocket connection, for example:</p> <pre><code>// Return response via POST response.\nlet response = Response::new()\n    .turbo_stream(&amp;[stream]);\n\n// Send it via WebSocket connection.\nComms::websocket(&amp;session_id)\n    .send(stream)\n</code></pre>"},{"location":"views/turbo/streams/#learn-more","title":"Learn more","text":"<ul> <li>WebSockets</li> <li>Template functions</li> <li>Sessions</li> <li>Hotwired Turbo Streams</li> </ul>"}]}